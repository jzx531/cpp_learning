<!DOCTYPE html><html><head>
      <title>learn_concurrency</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\jzx\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.15\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="c-concurrency-in-action">c++ concurrency in action </h1>

<div class="md-toc">
<details style="padding:0;;padding-left:0px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#c-concurrency-in-action" class="md-toc-link"><p>c++ concurrency in action</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#线程管控" class="md-toc-link">
            <p>线程管控</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#在线程间共享数据" class="md-toc-link"><p>在线程间共享数据</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#互斥锁" class="md-toc-link">
            <p>互斥锁</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#保护共享数据的其他工具" class="md-toc-link">
            <p>保护共享数据的其他工具</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#并发操作的同步" class="md-toc-link"><p>并发操作的同步</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#使用future等待一次性事件发生" class="md-toc-link"><p>使用future等待一次性事件发生</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#关联future实例和任务" class="md-toc-link">
            <p>关联future实例和任务</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#在线程间传递任务" class="md-toc-link">
            <p>在线程间传递任务</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#创建stdpromise" class="md-toc-link">
            <p>创建std::promise</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#将异常保存到future中" class="md-toc-link">
            <p>将异常保存到future中</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#多个线程一起等待" class="md-toc-link">
            <p>多个线程一起等待</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#限时等待" class="md-toc-link"><p>限时等待</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#后续函数的连锁调用" class="md-toc-link">
            <p>后续函数的连锁调用</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#线程闩和线程卡" class="md-toc-link">
            <p>线程闩和线程卡</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#stdexperimentalflex_barrier" class="md-toc-link">
            <p>std::experimental::flex_barrier</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#c内存模型和原子操作" class="md-toc-link"><p>c++内存模型和原子操作</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#同步操作和强制顺序" class="md-toc-link"><p>同步操作和强制顺序</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#同步关系" class="md-toc-link">
            <p>同步关系</p>

          </a></div><details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#先行关系" class="md-toc-link"><p>先行关系</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#先后一致顺序" class="md-toc-link">
            <p>先后一致顺序</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#非先后一致顺序" class="md-toc-link">
            <p>非先后一致顺序</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#宽松次序" class="md-toc-link">
            <p>宽松次序</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#获取-释放顺序" class="md-toc-link">
            <p>获取-释放顺序</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#获取-释放次序和memory_order_consume" class="md-toc-link">
            <p>获取-释放次序和memory_order_consume</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#栅栏" class="md-toc-link">
            <p>栅栏</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#凭借原子操作令非原子操作服从内存次序" class="md-toc-link">
            <p>凭借原子操作令非原子操作服从内存次序</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#设计基于锁的并发数据结构" class="md-toc-link"><p>设计基于锁的并发数据结构</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#设计更复杂的基于锁的并发数据结构" class="md-toc-link">
            <p>设计更复杂的基于锁的并发数据结构</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#设计无锁数据结构" class="md-toc-link"><p>设计无锁数据结构</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#无需等待的数据结构" class="md-toc-link"><p>无需等待的数据结构</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#实现线程安全的无锁队列" class="md-toc-link">
            <p>实现线程安全的无锁队列</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#实现无锁数据结构的原则" class="md-toc-link"><p>实现无锁数据结构的原则</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#原则1在原型设计中使用stdmemory_order_seq_cst次序" class="md-toc-link">
            <p>原则1：在原型设计中使用std::memory_order_seq_cst次序</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#原则2使用无锁的内存回收方案" class="md-toc-link">
            <p>原则2：使用无锁的内存回收方案</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#原则3-防范aba问题" class="md-toc-link">
            <p>原则3: 防范ABA问题</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#原则4找出忙等循环协助其他线程" class="md-toc-link">
            <p>原则4：找出忙等循环,协助其他线程</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#设计并发代码" class="md-toc-link"><p>设计并发代码</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#在线程间切分任务的方法" class="md-toc-link">
            <p>在线程间切分任务的方法</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#影响并发代码性能的因素" class="md-toc-link">
            <p>影响并发代码性能的因素</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#设计数据结构以提升多线程程序的性能" class="md-toc-link">
            <p>设计数据结构以提升多线程程序的性能</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#设计并发代码时额外要考虑的因素" class="md-toc-link">
            <p>设计并发代码时额外要考虑的因素</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#并发代码的设计实践" class="md-toc-link">
            <p>并发代码的设计实践</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#高级线程管理" class="md-toc-link"><p>高级线程管理</p>
</a>
          </summary>
        <div>
          <details style="padding:0;;padding-left:24px;" open="">
        <summary class="md-toc-link-wrapper">
          <a href="#线程池" class="md-toc-link"><p>线程池</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#任务窃取" class="md-toc-link">
            <p>任务窃取</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#中断线程" class="md-toc-link">
            <p>中断线程</p>

          </a></div>
        </div>
      </details>
    <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#并行算法函数" class="md-toc-link">
            <p>并行算法函数</p>

          </a></div><div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#多线程应用的测试和除错" class="md-toc-link">
            <p>多线程应用的测试和除错</p>

          </a></div>
        </div>
      </details>
    
</div>
<h2 id="线程管控">线程管控 </h2>
<p>每个c++程序都含有至少一个线程,即运行main()的线程,这些新线程连同其实线程并发运行,当main()函数返回时,程序就会退出</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">func</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span> i<span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span> i_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">i</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">1000</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    func <span class="token function">f</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>本例中,明确设定了不等待,于是在oops结束后，新线程可能继续运行,该线程可能访问已经被销毁的剧本变量,使线程错误</p>
<p>上述情形的处理方法是将数据完全复制给数据而不是共享<br>
为了防止因抛出异常而导致的应用程序终结,我们决定如何处理这种情况,一般地，如果读者打算在没发生异常的情况下调用join(),发生异常同样需要调用join()来确保线程安全</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">func</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> some_local_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    func <span class="token function">my_func</span><span class="token punctuation">(</span>some_local_state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>my_func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
        <span class="token function">do_something_in_current_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    <span class="token punctuation">}</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>为了实现前面的目标<br>
设计一个类,在标准类中运用RAII技术<br>
在析构函数中调用join()</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">thread_guard</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> t<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">thread_guard</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> _t<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">t</span><span class="token punctuation">(</span>_t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">thread_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">thread_guard</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> thread_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    thread_guard<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> thread_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>std:🧵:id 实例常用线程,</p>
<h2 id="在线程间共享数据">在线程间共享数据 </h2>
<h3 id="互斥锁">互斥锁 </h3>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;list&gt;</span></span>
std<span class="token double-colon punctuation">::</span>mutex some_mtx<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> some_list<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">add_to_list</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> new_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>some_mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    some_list<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-bool">bool</span> <span class="token function">list_contains</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>some_mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>some_list<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> some_list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">!=</span> some_list<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>为了避免在buffer构造函数没有原样复制所提供的值,并未令其转换为预期的参数类型,解决方法是,在buffer传入std::thread的构造函数之前,就把它转化成std::string对象</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token keyword keyword-void">void</span> <span class="token function">not_oops</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> some_param<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-char">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">sprintf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token string">"%d"</span><span class="token punctuation">,</span>some_param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>std::thread 的函数传入线程函数的参数时，线程库会把参数的引用传值当成move-only类型,并以右值传递,只要用std::ref()包装即可</p>
<p>std::thread t(update_data_for_widget,w,std::ref(data));</p>
<p>若要将某个类的成员函数设定为线程函数,我们则应该传入一个函数指针,指向该成员函数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
X my_x<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>X<span class="token double-colon punctuation">::</span>do_something<span class="token punctuation">,</span><span class="token operator">&amp;</span>my_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>c++11引入了另一种传递参数的方式:参数只能移动但不能复制,即数据从某个对象转移到另一个对象时,原对象则被搬空。这种型别的其中一个例子是std::unique_ptr,它为动态分配的对象提供自动化的内存管理<br>
在任何时候对于给定的对象,只可能存在唯一一个std::unique_ptr实例指向它;若实例被销毁,所指对象也被删除<br>
通过移动构造move constructor和移动赋值运算符move assignment operator,可以将std::unique_ptr实例从一个对象转移到另一个对象,而不用复制对象,这种移动使源对象变成null指针.</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">process_big_object</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>BigObject<span class="token operator">&gt;</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>BigObject<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> BigObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span><span class="token function">prepare_data</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>process_big_object<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>std::move()转移big_object的归属权</p>
<p>虽然std::thread类并不拥有动态对象，但它们拥有另一种资源，每份实例都负责管控一个执行线程.因为std::thread类的实例能够被移动却不能复制，故线程的归属权可以在其实例之间转移</p>
<p>只要std::thread对象正在管控着一个线程,就不能简单地向它赋新值,否则该线程会因此被遗弃</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">some_other_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t2<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> 
t1<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>some_other_function<span class="token punctuation">)</span><span class="token punctuation">;</span> 
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
t1<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误, t1正在运行线程</span>
</code></pre><p>从函数内部返回std::thread对象</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>thread <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">some_other_function</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>some_other_function<span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//类似的,若归属权可以转移到函数内部,函数就能接受std::thread实例作为按右值传递的参数</span>

<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>some_function<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">scoped_thread</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">scoped_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">logic_error</span><span class="token punctuation">(</span><span class="token string">"No thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">scoped_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">scoped_thread</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> scoped_thread<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    scoped_thread<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> scoped_thread<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">joining_thread</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">joining_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-noexcept">noexcept</span><span class="token operator">=</span> <span class="token keyword keyword-default">default</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Callable</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">joining_thread</span><span class="token punctuation">(</span>Callable<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Callable<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">joining_thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">joining_thread</span><span class="token punctuation">(</span>joining_thread<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token keyword keyword-noexcept">noexcept</span><span class="token operator">:</span><span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    joining_thread<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>joining_thread<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token keyword keyword-noexcept">noexcept</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">joining_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>joining_thread<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token keyword keyword-noexcept">noexcept</span><span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-noexcept">noexcept</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-noexcept">noexcept</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">logic_error</span><span class="token punctuation">(</span><span class="token string">"No thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">as_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-noexcept">noexcept</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">as_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword keyword-const">const</span> <span class="token keyword keyword-noexcept">noexcept</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>生成多个线程,并等待它们完成运作</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">do_work</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
        threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>do_work<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token operator">&amp;</span> t<span class="token operator">:</span>threads<span class="token punctuation">)</span><span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>线程安全的stack</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">empty_stack</span><span class="token operator">:</span><span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">exception</span></span><span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-throw">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_stack</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">threadsafe_stack</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_stack<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data<span class="token operator">=</span>other<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        threadsafe_stack<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_stack<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword keyword-throw">throw</span> <span class="token function">empty_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-auto">auto</span> res<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>条件竞争是两个线程同时抢先运行,死锁则是其反面,两个线程同时互相等待，停滞不前</p>
<p>c++提供std::lock()函数同时锁住多个互斥,而没有发生死锁的风险</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">some_big_object</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>some_big_objec<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>some_big_object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        some_big_object some_detail<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">X</span><span class="token punctuation">(</span>some_big_object <span class="token operator">&amp;</span> sd<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">some_detail</span><span class="token punctuation">(</span>sd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-friend">friend</span> <span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token operator">==</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
                <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock_a</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock_b</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>一开始对比两个参数,以确定它们指向不同实例,此项判断必不可少,原因是我们已经在std::mutex 上加锁,那么再次试图从该互斥锁将导致未定义的行为<br>
代码调用std::lock锁定两个互斥,并根据它们分别构造std::lock_guard实例<br>
我们除了使用互斥当这两个实例的构造参数,还额外提供了std::adopt_lock对象,以指明互斥已被锁住,即互斥上有锁的存在<br>
std::lock函数在获取锁的过程中,如果有异常,会释放它的所获得的所有锁</p>
<p>针对以上场景,c++17引入了std::scoped_lock,它可以同时锁住多个互斥,并在析构时自动解锁,而不需要手动解锁</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token operator">==</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>scoped_lock <span class="token function">guard</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>虽然死锁的最常见诱因是锁操作,但即使没有牵涉锁,也会发生死锁操作.假定有两个线程,各自关联了std::thread实例,若它们同时在对方的std::thread实例上调用join(),就能制造死锁现象却不涉及锁操作</p>
<mark>
防范死锁的准则最终可归纳成一个思想:只要另一线程有可能正在等待当前线程,那么当前线程不能反过来等待它
</mark>
<ol>
<li>避免嵌套锁</li>
<li>一但持锁,就必须避免调用由用户提供的程序接口</li>
<li>依从固定顺序获取锁</li>
</ol>
<p>假如A和B两个相邻节点,正向遍历进程先获取A锁再获取B锁，反向遍历进程先获取B锁再获取A锁,则会发生死锁</p>
<ol start="4">
<li>按层级加锁</li>
</ol>
<p>把应用程序分层,并且明确每个互斥位于哪个层级.若某线程以对低层级互斥加锁,则不准它再对高层级互斥加锁,具体做法是将顶层的编号赋予对应层级应用程序上的互斥,并记录各线程分别锁定了哪些互斥</p>
<p>下面这个例子示范了两个线程如何运用层级互斥</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>hierachical_mutex <span class="token function">high_level_mutex</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hierachical_mutex <span class="token function">low_level_mutex</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hierachical_mutex <span class="token function">other_mutex</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-int">int</span> <span class="token function">do_low_level_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">low_level_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>hierachical_mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>low_level_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">do_low_level_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">high_level_stuff</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> some_param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">high_level_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>   
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>hierachical_mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>high_level_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">high_level_stuff</span><span class="token punctuation">(</span><span class="token function">low_level_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">thread_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">high_level_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">other_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>hierachical_mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>other_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">thread_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>hierachical_mutex<span class="token operator">&gt;</span><span class="token function">lk</span><span class="token punctuation">(</span>other_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上式中thread_b违反了规则,thread_b锁住了中层锁,但内部却索取了高级锁,会报错或发生异常<br>
为自定义的hierarchical_mutex类实现层级互斥<br>
为了使用lock_guard 锁住互斥，我们需要实现<br>
lock(),unlock()函数,以及try_lock()函数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">hierachical_mutex</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>mutex internal_mutex<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hierachy_value<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> previous_hierachy_value<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-thread_local">thread_local</span> <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> this_thread_hierachy_value<span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">check_for_hierarchy_violation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>this_thread_hierachy_value <span class="token operator">&lt;=</span>hierachy_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">logic_error</span><span class="token punctuation">(</span><span class="token string">"Hierachy violation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">update_hierachy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        previous_hierachy_value <span class="token operator">=</span> this_thread_hierachy_value<span class="token punctuation">;</span>
        this_thread_hierachy_value <span class="token operator">=</span> hierachy_value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">hierachical_mutex</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> value<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">hierachy_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">previous_hierachy_value</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">check_for_hierarchy_violation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       internal_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">update_hierachy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>this_thread_hierachy_value <span class="token operator">!=</span> hierachy_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">logic_error</span><span class="token punctuation">(</span><span class="token string">"Hierachy violation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        this_thread_hierachy_value <span class="token operator">=</span> previous_hierachy_value<span class="token punctuation">;</span>
        internal_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">check_for_hierarchy_violation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>internal_mutex<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">update_hierachy_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-thread_local">thread_local</span> <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> hierachical_mutex<span class="token double-colon punctuation">::</span><span class="token function">this_thread_hierachy_value</span><span class="token punctuation">(</span>ULLONG_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><p>开始阶段,将层级编号定义为最大<br>
任意hierachical_mutex互斥都能被加锁。因此声明由thread_local修饰,每个线程都具有自己的this_thread_hierachy_value副本,所以该变量在某个线程上的值与另一线程值完全无关,</p>
<p>运用std::unique_lock&lt;&gt;灵活加锁</p>
<p>构造函数接受第二参数,可以传入<br>
例如:adopt_lock实例,以指明std::unique_lock对象管理互斥上的锁</p>
<p>传入std::defer_lock使互斥在完成构造时处于无锁状态</p>
<p>std::unique_lock对象可以不占有关联的互斥<br>
但比std::lock_guard略慢且占用更多的空间</p>
<p>ock_guard 是基于互斥锁 std::mutex 实现的，unique_lock 是基于通用锁 std::unique_lock 实现的，unique_lock 可以实现比 lock_guard 更灵活的锁操作。<br>
lock_guard 是不可移动的（moveable），即不能拷贝、赋值、移动，只能通过构造函数初始化和析构函数销毁，unique_lock 是可移动的，可以拷贝、赋值、移动。<br>
unique_lock 提供了更多的控制锁的行为，比如锁超时、不锁定、条件变量等。<br>
unique_lock 比 lock_guard 更重，因为它有更多的功能，更多的开销。如果只需要简单的互斥保护，使用 lock_guard 更好。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">some_big_object</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>some_big_object<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>some_big_object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        some_big_object some_detail<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">X</span><span class="token punctuation">(</span>some_big_object <span class="token operator">&amp;</span> sd<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">some_detail</span><span class="token punctuation">(</span>sd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-friend">friend</span> <span class="token keyword keyword-void">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token operator">==</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
                <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock_a</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>mtx<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock_b</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>mtx<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>defer_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>lock_a<span class="token punctuation">,</span>lock_b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时才对互斥加锁</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>some_detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>互斥的归属权可以在多个std::unique_lock实例之间转移,但不能复制<br>
转移可以自动发生,譬如从函数返回实例时,但我们必须针对别的情形调用std::move()<br>
std::unique_lock可转移不可复制</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">get_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-extern">extern</span> std<span class="token double-colon punctuation">::</span>mutex some_mutex<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>some_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">prepare_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> lk<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span><span class="token function">get_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_something_with_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的模式主要在两种情形下使用:</p>
<ol>
<li>互斥加锁的时机取决于程序的当前状态;</li>
<li>或者,某函数负责执行加锁操作并返回std::unique_lock对象,而互斥加锁时机则由传入的参数决定</li>
</ol>
<p>锁的角色是其数据成员,用于保证只有正确加锁才能够访问受保护数据<br>
所有数据通过通道类访问,若想访问数据,则需要先取得通道类的实例<br>
再借它执行加锁操作,然后通过通道对象的成员函数才得以访问数据</p>
<p>我们在访问完成后销毁通道对象,锁随之释放<br>
std::unique_lock类允许它的实例在被销毁前解锁<br>
其成员函数unlock()负责解锁操作,这与互斥一致</p>
<p>持锁期间应避免任何耗时的操作,如读写文件<br>
同样是读写文件总量相等的数据,文件操作会慢的多</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">get_and_process_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">my_lock</span><span class="token punctuation">(</span>the_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    some_class data_to_process <span class="token operator">=</span> <span class="token function">get_next_data_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    my_lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//假定process无需加锁</span>
    result_type result <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>data_to_process<span class="token punctuation">)</span><span class="token punctuation">;</span>
    my_lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">write_result</span><span class="token punctuation">(</span>data_to_process<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>在比较运算的过程中,每次只锁住一个互斥</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">Y</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-int">int</span> some_detail<span class="token punctuation">;</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
        <span class="token keyword keyword-int">int</span> <span class="token function">get_detail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> some_detail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">Y</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> sd<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">some_detail</span><span class="token punctuation">(</span>sd<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-friend">friend</span> <span class="token keyword keyword-bool">bool</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> Y<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span><span class="token keyword keyword-const">const</span> Y<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs<span class="token operator">==</span><span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-int">int</span> <span class="token keyword keyword-const">const</span> lhs_detail <span class="token operator">=</span> lhs<span class="token punctuation">.</span><span class="token function">get_detail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-int">int</span> <span class="token keyword keyword-const">const</span> rhs_detail <span class="token operator">=</span> rhs<span class="token punctuation">.</span><span class="token function">get_detail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> lhs_detail<span class="token operator">==</span>rhs_detail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h3 id="保护共享数据的其他工具">保护共享数据的其他工具 </h3>
<p>假设我们需要某个共享数据,而它创建起来开销不菲<br>
所以等到必要时才真正着手创建,这种方式称为延迟初始化</p>
<p>用互斥实现线程安全的延迟初始化</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>some_resource<span class="token operator">&gt;</span> resource_ptr<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex resource_mutex<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//此处,全部线程都被迫运行</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>resource_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>resource_ptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        resource_ptr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> some_resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    resource_ptr<span class="token operator">-&gt;</span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>必要的同步数据由std::once_flag实例存储<br>
每个std::once_flag 实例对应一次不同的初始化</p>
<p>相比显式使用互斥,std::call_once()函数的额外开销往往更低</p>
<p>特别是在初始化已经完成的情况下,如果功能符合需求就应优先使用</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>some_resource<span class="token operator">&gt;</span> resource_ptr<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>once_flag resource_flag<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">init_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    resource_ptr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> some_resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//初始化函数准确地被唯一一次调用</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>resource_flag<span class="token punctuation">,</span>init_resource<span class="token punctuation">)</span>
    resource_ptr<span class="token operator">-&gt;</span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        connection_info connection_details<span class="token punctuation">;</span>
        connection_handle connection<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>once_flag connection_init_flag<span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">open_connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            connection <span class="token operator">=</span> connection_manager<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>connection_details<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">X</span><span class="token punctuation">(</span>connection_info <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> connection_details_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">connection_details</span><span class="token punctuation">(</span>connection_details_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">send_data</span><span class="token punctuation">(</span>data_packet <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>connection_init_flag<span class="token punctuation">,</span><span class="token operator">&amp;</span>X<span class="token double-colon punctuation">::</span>open_connection<span class="token punctuation">,</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            connection<span class="token punctuation">.</span><span class="token function">send_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        data_packet <span class="token function">receive_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>connection_init_flag<span class="token punctuation">,</span><span class="token operator">&amp;</span>X<span class="token double-colon punctuation">::</span>open_connection<span class="token punctuation">,</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> connection<span class="token punctuation">.</span><span class="token function">receive_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>c++11规定初始化只会在某一线程上单独发生,在初始化完成之前,<br>
其他线程不会越过静态数据的声明而继续运行</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">my_class</span><span class="token punctuation">;</span>
my_class<span class="token operator">&amp;</span> <span class="token function">get_my_class_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-static">static</span> my_class instance<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>多个线程可以安全调用get_my_class_instance()函数,而无须担忧初始化条件的竞争</p>
<p>考虑一个存储着DNS条目的缓存表,它将域名解释成对应的IP地址<br>
给定DNS条目通常在很长时间内都不会变化<br>
DNS条目保持多年不变.尽管随着用户访问不同网站,缓存表会不时加入新条目,但在很大程度上<br>
数据在整个生命期内将保持不变。为了判断数据是否有效,必须定期检查缓存表</p>
<p>std::mutex过于严苛,即使没有发生数据变动，照样会禁止并发访问，由于新的互斥具有两种不同的使用方式,因此通常被称为读写互斥</p>
<p>c++17提供,利用std::shared_mutex实施同步操作.更新操作可用std::lock_guard<a href="std::shared_mutex">std::shared_mutex</a>加锁,而读取操作可用std::shared_lock<a href="std::shared_mutex">std::shared_mutex</a>和std::unique_lock<a href="std::shared_mutex">std::shared_mutex</a>加锁</p>
<p>对于写看使用std::shared_lock<a href="std::shared_mutex">std::shared_mutex</a>实现共享访问</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;shared_mutex&gt;</span></span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">dns_entry</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">dns_cache</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span>dns_entry<span class="token operator">&gt;</span> cache<span class="token punctuation">;</span>
    <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>shared_mutex cache_mutex<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    dns_entry <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> <span class="token function">get_entry</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> domain<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>entry_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span>dns_entry<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>domain<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> entries<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token function">dns_entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>it<span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">update_or_add_entry</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> domain<span class="token punctuation">,</span>dns_entry <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> dns_details<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>entry_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        entries<span class="token punctuation">[</span>domain<span class="token punctuation">]</span><span class="token operator">=</span>dns_details<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>加入线程已经持有某个std::mutex实例,试图再次对其重新加锁就会出错,将导致未定义的行为。但在某些场景中,却有需要让线程在同一互斥上多次重复加锁,而无须解锁，c++标准库为此提供了std::recursive_mutex,其工作方式与std::mutex相似,不同之处，其允许同一线程对某互斥的同一实例多次加锁</p>
<p>比如当公有函数调用另一个公有函数<br>
容许第二个公有函数成功地对递归互斥加锁<br>
但一般更好的方法是根据这两个公有函数的共同部分,提取出一个新的私有函数</p>
<h2 id="并发操作的同步">并发操作的同步 </h2>
<p>凭借条件变量等待条件成立</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">data_chunk</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-int">int</span> data<span class="token punctuation">;</span>
    <span class="token function">data_chunk</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
data_chunk <span class="token function">prepare_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">data_chunk</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token double-colon punctuation">::</span>mutex mut<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>data_chunk<span class="token operator">&gt;</span> data_queue<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable data_cond<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">data_preparation_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       data_chunk <span class="token keyword keyword-const">const</span> data <span class="token operator">=</span> <span class="token function">prepare_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
        data_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       data_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">data_processing_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
        data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span><span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        data_chunk data <span class="token operator">=</span> data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Processing data: "</span> <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span>data <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>std::condition_variable实例上调用wait(),传入锁对象和一个lamda函数,后者用于表达需要等待成立的条件,lamda函数是c++11的新特性<br>
wait()在内部调用传入的lamda函数,判断条件是否成立;若成立(lamda函数返回true)则wait()返回,否则wait()解锁互斥,并令线程进入阻塞状态或等待状态<br>
数据准备线程调用notify_one()通知条件变量,线程甲随之从休眠中觉醒,重新在互斥上获取锁，再次查验条件;若条件成立,则从wait()函数返回,仍获取锁，而如果条件不成立，就解锁互斥继续等待</p>
<p>使用unique_lock就是为了让处理数据的线程甲能够释放互斥</p>
<p>利用条件变量构建线程安全的队列</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex mut<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data_queue<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>condition_variable data_cond<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span>threadsafe_queue <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue <span class="token operator">=</span> other<span class="token punctuation">.</span>data_queue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span><span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span><span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_gurad<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><hr>
<mark>
在C++中，std::adopt_lock是一个锁定策略，它告诉lock_guard或unique_lock对象，互斥量在传递给锁定对象之前已经被当前线程锁定。这意味着锁定对象在构造时不会尝试锁定互斥量，而是“收养”已经存在的锁。
</mark>
<hr>
<mark>
当你需要对多个互斥体进行操作时，使用std::defer_lock可以避免死锁的风险。例如，如果你创建了两个std::unique_lock对象并分别对两个互斥体上锁，如果两个线程中的一个先锁定了第一个互斥体，而另一个线程先锁定了第二个互斥体，就可能发生死锁。使用std::defer_lock，你可以延迟锁定操作，直到可以安全地同时锁定两个互斥体。
</mark>
<hr>
<h3 id="使用future等待一次性事件发生">使用future等待一次性事件发生 </h3>
<p>c++标准程序库使用future来模拟这类一次性事件:若线程需要等待某个特定的一次性事件发生,则会以恰当的方式取得一个future，它代表目标事件,接着，线程就能一边执行其他任务一边在future上等待；同时,它以短暂的间隔反复查验目标事件已经发生<br>
该线程也可以转换运行模式,先不等目标事件发生，直接暂缓当前任务而切换到别的任务,及至必要时,才回头等待future准备就绪，future可能与数据相关也可能未相关<br>
一旦目标事件发生,其future就进入就绪状态,无法重置</p>
<p>c++标准程序库有两种future,分别由两个类模板实现，其声明位于标准库的头文件<future>内，独占future(unique_future,即std::future&lt;&gt;)和共享fture(shared_future&lt;&gt;)</future></p>
<p>同一事件仅仅允许关联唯一一个std::future实例,但可以关联多个std::shared_future实例,只要目标事件发生,与后者关联的所有实例就会同步就绪，并且他们全都可以访问与该目标事件关联的任何数据，关联数据正是两种future以模板形式实现的原因</p>
<p>如果没有关联数据，我们应使用特化的模板std::future<void>和std::shared_future<void></void></void></p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword keyword-int">int</span> <span class="token function">find_the_answer_to_ltuae</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> the_answer <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>find_the_answer_to_ltuae<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_other_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The answer to life, the universe, and everything is: "</span> <span class="token operator">&lt;&lt;</span> the_answer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>std::async()和std::thread的构造函数相同，若要异步运行某个类的某成员函数,则std::async()的第一个参数应是一个函数指针，指向该类的目标成员函数,用作成员函数的参数</p>
<p>给std::async()补充一个参数,以指定采用哪种运行方式.参数类型为std::launch</p>
<p><mark>1. std::launch::deferred:前者指定在当前线程上延后调用任务函数,等到future上调用了wait或get，任务函数才会执行;<br>
2. std::launch::async:后者指定在一个新的线程上异步运行任务函数,future上调用wait或get时,任务函数已经完成,返回值也已经可用;<br>
3. std::launch::async|std::launch::deferred:表示由std::async()选择运行方式,该项是默认项<br>
</mark></p>
<h4 id="关联future实例和任务">关联future实例和任务 </h4>
<p>std::packaged_task&lt;&gt;连接了future对象与函数，其对象执行任务时会调用关联的函数(或可调用对象),把返回值保存为future的内部数据,并令future准备就绪.它可作为线程池的构建单元<br>
std::packaged_task&lt;&gt;是类模板,其模板参数是函数签名，譬如void()表示一个函数,不接受参数，也没有返回值，int(std::string&amp;,double*)代表某函数,它接收两个参数并返回int值,其中第一个参数是非const引用,指向std::string对象,第二个参数是double类型指针.<br>
类模板std::packaged_task&lt;&gt;具有成员函数get_future(),它返回std::future&lt;&gt;实例，该future的特化类型取决于函数签名所指定的返回值<br>
定义特化的std::packaged_task&lt;&gt;类模板</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">packaged_task</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Callable</span><span class="token operator">&gt;</span>
        <span class="token keyword keyword-explicit">explicit</span> <span class="token function">packaged_task</span><span class="token punctuation">(</span>Callable<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-char">char</span><span class="token operator">&gt;</span><span class="token operator">*</span> data<span class="token punctuation">,</span><span class="token keyword keyword-int">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h4 id="在线程间传递任务">在线程间传递任务 </h4>
<p>许多图形用户界面GUI框架都设立了专门的线程,作为更新界面的实际执行者.若别的线程需要更新界面,就必须向它发送消息,由它执行操作</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;deque&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;utility&gt;</span></span>

std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> tasks<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">gui_shutdown_message_received</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">get_and_process_gui_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">gui_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">gui_shutdown_message_received</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">get_and_process_gui_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> task<span class="token punctuation">;</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tasks<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
            task<span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>tasks<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tasks<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
        <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">gui_bg_thread</span><span class="token punctuation">(</span>gui_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> <span class="token function">post_task_for_gui_thread</span><span class="token punctuation">(</span>Func f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> res<span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tasks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><h4 id="创建stdpromise">创建std::promise </h4>
<p>std::promise和std::future组合使用,可以使：等待数据的线程在future上阻塞，而提供数据的线程利用相配的promise设定关联的值,使future准备就绪</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token keyword keyword-void">void</span> <span class="token function">process_connections</span><span class="token punctuation">(</span>connection_set<span class="token operator">&amp;</span> connections<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">done</span><span class="token punctuation">(</span>connections<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>connection_set<span class="token double-colon punctuation">::</span>iterator connection<span class="token operator">=</span>connections<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connection<span class="token operator">!=</span>connections<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>connection<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>connection<span class="token operator">-&gt;</span><span class="token function">has_incoming_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                data_packet data<span class="token operator">=</span>connection<span class="token operator">-&gt;</span><span class="token function">incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>payload_type<span class="token operator">&gt;</span><span class="token operator">&amp;</span> p <span class="token operator">=</span> it<span class="token operator">-&gt;</span><span class="token function">get_promise</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>connection<span class="token operator">-&gt;</span><span class="token function">has_outgoing_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                outgoing_data data<span class="token operator">=</span>connection<span class="token operator">-&gt;</span><span class="token function">outgoing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> p <span class="token operator">=</span> it<span class="token operator">-&gt;</span><span class="token function">get_promise</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                data<span class="token punctuation">.</span>promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="将异常保存到future中">将异常保存到future中 </h4>
<p>async()抛出的异常只要调用get(),该异常就会再次被抛出</p>
<p>std::promise也具有同样的功能,它通过成员函数的显示调用实现,假如想保存异常<br>
使用set_exception()</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-extern">extern</span> std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword keyword-double">double</span><span class="token operator">&gt;</span>some_promise<span class="token punctuation">;</span>
<span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
    some_promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token function">calculate_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    some_promise<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//此外还能用std::make_exception_ptr()保存新异常而不出发抛出</span>
some_promise<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">make_exception_ptr</span><span class="token punctuation">(</span><span class="token function">my_exception</span><span class="token punctuation">(</span><span class="token string">"error message"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="多个线程一起等待">多个线程一起等待 </h4>
<p>当std::shared_future的实例依据std::future的实例构造而得,前者所指向的异步状态由后者决定.因为std::future对象独占异步状态，其归属权不为其他任何对象所共有,所以若要按默认方式构造std::shared_future对象，则必须用std::move向其默认构造函数传递归属权,这使std::future变为空状态</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span>p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token function">sf</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//隐式归属权转移</span>
</code></pre><p>std::future还具有可以根据初始化列表自动推断变量的类型从而使std::shared_future的实例化更加方便的特点</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>someIndexType<span class="token punctuation">,</span>SomeDataType<span class="token punctuation">,</span>SomeComparator<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
<span class="token keyword keyword-auto">auto</span> sf<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> f <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> sf <span class="token operator">=</span> f<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> sf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre><h3 id="限时等待">限时等待 </h3>
<p>有两种超时机制可以使用</p>
<ol>
<li>延迟超时:线程根据指定的时长而继续等待</li>
<li>绝对超时:在某特定时间点来临之前,线程一直等待。</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> f<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>some_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>
<span class="token function">do_something_with_result</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>就变量进行限时等待</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> done<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token function">wait_loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token keyword keyword-const">const</span> timeout <span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>cv<span class="token punctuation">.</span><span class="token function">wait_until</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span>timeout<span class="token punctuation">)</span><span class="token operator">==</span>std<span class="token double-colon punctuation">::</span>cv_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> done<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>超时时限的最简单用途是推迟特定线程的处理过程,若它不运行,就不会占用其他线程的处理时间,从而避免资源竞争</p>
<p>在给互斥加锁时,也能设定超时时限</p>
<p>使用<mark>std::timed_mutex</mark>和<mark>std::recursive_timed_mutex</mark>可以设定超时时限,这两种锁都含有成员函数try_lock_for()和try_lock_until()</p>
<p><img src="timeout_in_cpp.png" alt="alt text"></p>



    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Standard Library Functions</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>


<h1>C++ Standard Library Functions with Timeout</h1>
<table>
    <thead>
        <tr>
            <th>类/命名空间</th>
            <th>C++标准库中接收超时的函数</th>
            <th>返回值</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>std::this_thread</td>
            <td>sleep_for(duration)<br>sleep_until(time_point)</td>
            <td>无</td>
        </tr>
        <tr>
            <td>std::condition_variable或std::condition_variable_any</td>
            <td>wait_for(lock, duration)<br>wait_until(lock, time_point, predicate)</td>
            <td>Bool - 被唤醒时的返回值</td>
        </tr>
        <tr>
            <td>std::timed_mutex<br>std::recursive_timed_mutex<br>std::shared_timed_mutex</td>
            <td>try_lock_for(duration)<br>try_lock_until(time_point)</td>
            <td>Bool - 若获得锁，则返回true，否则返回false</td>
        </tr>
        <tr>
            <td>std::unique_lock<timed lockable=""></timed></td>
            <td>try_lock_for(duration)<br>try_lock_until(time_point)</td>
            <td>无 - 如果在新构建的对象上获得锁，则返回true，否则返回false</td>
        </tr>
        <tr>
            <td>std::shared_lock<shared timedlockable=""></shared></td>
            <td>try_lock_for(duration)<br>try_lock_until(time_point)</td>
            <td>Bool - 若获得锁，则返回true，否则返回false</td>
        </tr>
        <tr>
            <td>std::future<valuetype>或std::shared_future<valuetype></valuetype></valuetype></td>
            <td>wait_for(duration)<br>wait_until(time_point)</td>
            <td>如果等待超时返回std::future_status::timeout<br>如果准备则返回std::future_status::ready<br>如果被延迟则返回std::future_status::deferred</td>
        </tr>
    </tbody>
</table>


<p>快速排序的串行实现</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">sequential_quick_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> input<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    T <span class="token keyword keyword-const">const</span> <span class="token operator">&amp;</span> pivot<span class="token operator">=</span><span class="token operator">*</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> divide<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">partition</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x<span class="token operator">&lt;</span>pivot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lower_part<span class="token punctuation">,</span>higher_part<span class="token punctuation">;</span>
    lower_part<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>lower_part<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>divide<span class="token punctuation">)</span><span class="token punctuation">;</span>
    higher_part<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>higher_part<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">,</span>lower_part<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">new_lower</span><span class="token punctuation">(</span><span class="token function">sequential_quick_sort</span><span class="token punctuation">(</span>lower_part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">new_higher</span><span class="token punctuation">(</span><span class="token function">sequential_quick_sort</span><span class="token punctuation">(</span>higher_part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_higher<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_lower<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//运用future实现并行快速排序</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">parallel_quick_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> input<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> input<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> pivot<span class="token operator">=</span><span class="token operator">*</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> divide<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">partition</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x<span class="token operator">&lt;</span>pivot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> divide_point <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">partition</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> x<span class="token operator">&lt;</span>pivot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> lower_part<span class="token punctuation">;</span>
    lower_part<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>lower_part<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">,</span>input<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>divide_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>new_lower<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>parallel_quick_sort<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>lower_part<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> new_higher<span class="token operator">=</span><span class="token function">parallel_quick_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_higher<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>最大的变化就是前半部分的排序不再由当前线程执行,而是通过std::async()在另一线程上操作</p>
<p>如果层数过高,可能会导致线程过多<br>
除了使用std::async()之外</p>
<p>spawn_task()的简单实现</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">A</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>result_of_t<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type <span class="token function">spawn_task</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span>A<span class="token operator">&amp;&amp;</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> result_type<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>result_of_t<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">result_type</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span>
    <span class="token function">res</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    task<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>与std::async()等价的函数,其中运用了并发技术规约中的std::experimental<br>
::future还具有可以根据初始化列表自动推断变量的类型从而使std</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>Func<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token function">spawn_task</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>Func<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>p<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> res  <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>p<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span>f<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">decay_t</span><span class="token generic class-name"><span class="token operator">&lt;</span>Func<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-mutable">mutable</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_exception_at_thread_exit</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="后续函数的连锁调用">后续函数的连锁调用 </h4>
<p>假定有一系列耗时的任务需要执行,而且，为了让主线程抽身执行其他任务,我们想按异步方式执行这些任务</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span>  <span class="token function">process_login</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span> <span class="token operator">&amp;</span> username<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> password<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
        user_id <span class="token keyword keyword-const">const</span> id <span class="token operator">=</span> backend<span class="token punctuation">.</span><span class="token function">authenticate_user</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
        user_data <span class="token keyword keyword-const">const</span> info_to_display <span class="token operator">=</span> backend<span class="token punctuation">.</span><span class="token function">request_current_info</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">update_display</span><span class="token punctuation">(</span>info_to_display<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">display_error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>使用后续函数处理用户登录</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> <span class="token function">process_login</span><span class="token punctuation">(</span>
    std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> username<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> password
<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">spawn_task</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> backend<span class="token punctuation">.</span><span class="token function">authenticate_user</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>user_id<span class="token operator">&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> backend<span class="token punctuation">.</span><span class="token function">request_current_info</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>user_data<span class="token operator">&gt;</span>info_to_display<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
            <span class="token function">update_display</span><span class="token punctuation">(</span>info_to_display<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">display_error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token comment">// 定义一个支持 then 的 future 类模板</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">MyFuture</span> <span class="token punctuation">{</span>
<span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">MyFuture</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> future<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">future_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token function">then</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-using">using</span> ResultType <span class="token operator">=</span> <span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>future_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>ResultType<span class="token operator">&gt;</span> promise<span class="token punctuation">;</span>
        <span class="token keyword keyword-auto">auto</span> resultFuture <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">,</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">,</span> future <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>future_<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_exception_at_thread_exit</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token generic-function"><span class="token function">MyFuture</span><span class="token generic class-name"><span class="token operator">&lt;</span>ResultType<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>resultFuture<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> <span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>future_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword keyword-private">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> future_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 辅助函数，用于创建 MyFuture 对象</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-auto">auto</span> <span class="token function">make_my_future</span><span class="token punctuation">(</span>Func<span class="token operator">&amp;&amp;</span> func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-using">using</span> ResultType <span class="token operator">=</span> <span class="token keyword keyword-decltype">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>ResultType<span class="token operator">&gt;</span> promise<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> future <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">,</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Func<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-mutable">mutable</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">.</span><span class="token function">set_value_at_thread_exit</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p<span class="token punctuation">.</span><span class="token function">set_exception_at_thread_exit</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token generic-function"><span class="token function">MyFuture</span><span class="token generic class-name"><span class="token operator">&lt;</span>ResultType<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-auto">auto</span> future <span class="token operator">=</span> <span class="token function">make_my_future</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"First task running..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-auto">auto</span> nextFuture <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Second task running with result: "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread continues..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 获取最终结果</span>
    <span class="token keyword keyword-try">try</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> finalResult <span class="token operator">=</span> nextFuture<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Third task running with result: "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> result <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final result: "</span> <span class="token operator">&lt;&lt;</span> finalResult <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-catch">catch</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Exception: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>使用std::async()从多个future收集结果</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;</span> <span class="token function">process_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>MyData<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t <span class="token keyword keyword-const">const</span> chunk_size <span class="token operator">=</span>whatever<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>chunkResult<span class="token operator">&gt;&gt;</span>results<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> begin<span class="token operator">=</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token operator">=</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>begin<span class="token operator">!=</span>end<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        size_t <span class="token keyword keyword-const">const</span> remaining_size<span class="token operator">=</span>end<span class="token operator">-</span>begin<span class="token punctuation">;</span>
        size_t <span class="token keyword keyword-const">const</span> this_chunk_size<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>remaining_size<span class="token punctuation">,</span>chunk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        results<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>process_chunk<span class="token punctuation">,</span>begin<span class="token punctuation">,</span>begin<span class="token operator">+</span>this_chunk_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            begin<span class="token operator">+=</span>this_chunk_size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span>all_results<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>chunkResult<span class="token operator">&gt;</span> all_chunks<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token operator">&amp;</span> f<span class="token operator">:</span>all_results<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
all_chunks<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">gather_results</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面的代码会在get()处反复被唤醒,不过,若它发现有任务尚未得出结果,旋即再次休眠<br>
上述"等待-切换"的行为属实无用</p>
<p>采用std::experimental::when_all()函数从多个future收集结果</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;</span> <span class="token function">process_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>MyData<span class="token operator">&gt;</span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t <span class="token keyword keyword-const">const</span> chunk_size <span class="token operator">=</span>whatever<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>ChunkResult<span class="token operator">&gt;&gt;</span>results<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> begin<span class="token operator">=</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token operator">=</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>begin<span class="token operator">!=</span>end<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        size_t <span class="token keyword keyword-const">const</span> remaining_size<span class="token operator">=</span>end<span class="token operator">-</span>begin<span class="token punctuation">;</span>
        size_t <span class="token keyword keyword-const">const</span> this_chunk_size<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>remaining_size<span class="token punctuation">,</span>chunk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        results<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>
            <span class="token function">spawn_async</span><span class="token punctuation">(</span>process_chunk<span class="token punctuation">,</span>begin<span class="token punctuation">,</span>begin<span class="token operator">+</span>this_chunk_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            begin<span class="token operator">+=</span>this_chunk_size<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span><span class="token function">when_all</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>results<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>ChunkResult<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>ready_results<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>ChunkResult<span class="token operator">&gt;&gt;</span>results<span class="token operator">=</span>ready_results<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>ChunkResult<span class="token operator">&gt;</span>v<span class="token punctuation">;</span>
        v<span class="token punctuation">.</span><span class="token function">rerserve</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token operator">&amp;</span> f<span class="token operator">:</span>results<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">gather_results</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><mark>
实验标头不是标准的一部分。实现可以提供它们，但不需要这样做。
它们是为C++委员会正在致力于将其纳入未来标准的特性定义的。
VisualStudio2019和2022都不提供<experimental future=""></experimental></mark>
<p>std::experimental::when_any()函数为当生成多个任务同时运行,但只要其中一个完成运行,我们就需要马上另外处理该项最先得出的结果</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;</span><span class="token function">find_and_process_value</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>MyData<span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> concurrency<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> num_tasks<span class="token operator">=</span><span class="token punctuation">(</span>concurrency<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span>concurrency<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>MyData<span class="token operator">*</span><span class="token operator">&gt;&gt;</span>results<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> <span class="token keyword keyword-const">const</span> chunk_size<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>num_tasks<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>num_tasks<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> chunk_begin<span class="token operator">=</span>data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;&gt;</span>done_flag<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_tasks<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-auto">auto</span> chunk_end <span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span>num_tasks<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">?</span>chunk_begin<span class="token operator">+</span>chunk_size<span class="token operator">:</span>data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        results<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">spawn_async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span> it<span class="token operator">=</span>chunk_begin<span class="token punctuation">;</span><span class="token operator">!</span><span class="token operator">*</span>done_flag<span class="token operator">&amp;&amp;</span>it<span class="token operator">!=</span>chunk_end<span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">matches_find_criteria</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                  <span class="token operator">*</span>done_flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                  <span class="token keyword keyword-return">return</span> <span class="token operator">&amp;</span><span class="token operator">*</span>entry<span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>MyData<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        chunk_begin<span class="token operator">=</span>chunk_end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;&gt;</span>
    final_result <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">DoneCheck</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;&gt;</span>final_result<span class="token punctuation">;</span>
        <span class="token function">DoneCheck</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>FinalResult<span class="token operator">&gt;&gt;</span>final_result<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">final_result</span><span class="token punctuation">(</span>final_result<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>when_any_result<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>MyData<span class="token operator">*</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span> results_param<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-auto">auto</span> results <span class="token operator">=</span> results_param<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                MyData<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> ready_result<span class="token operator">=</span>results<span class="token punctuation">.</span>futures<span class="token punctuation">[</span>results<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>ready_result<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    final_result<span class="token operator">-&gt;</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token function">process_result</span><span class="token punctuation">(</span><span class="token operator">*</span>ready_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span>
                <span class="token punctuation">{</span>
                    final_result<span class="token operator">-&gt;</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">make_exception_ptr</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"No matching value found"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span><span class="token function">when_any</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>results<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">DoneCheck</span><span class="token punctuation">(</span>final_result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> final_result<span class="token operator">-&gt;</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="线程闩和线程卡">线程闩和线程卡 </h4>
<p>线程闩latch,是一个同步对象,内含计数器,一旦减到0,就会进入就绪状态</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> thread_count<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
    latch <span class="token function">done</span><span class="token punctuation">(</span>thread_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    my_data data<span class="token punctuation">[</span>thread_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>thread_count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">{</span>
            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">process_data</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            done<span class="token punctuation">.</span><span class="token function">count_down</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">do_more_stuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>基本的线程卡类std::experimental::barrier<br>
和std::experimental::flex_barrier<br>
假定有一组线程在协同处理某些数据,各线程相互独立,分别处理数据,因此操作过程不必同步.但是只有在全部线程完成各自的处理后,才可以操作下一项数据或开始后续处理,std::experimental:: barrier针对的就是这种场景</p>
<p>创建线程卡,线程在完成自身的处理后,就运行到线程卡处,通过在线程卡对象上调用arrive_and_wait()等待同步组的其他线程,只要组内最后一个线程也运行至此,所有线程即被释放，线程卡会自我重置</p>
<p>只要线程卡上调用arrive_and_drop(),即可令线程显示脱离其同步组,那样,它就再也无法被阻拦,因而也不能等待线程卡进入就绪状态,并且,在下一个同步周期中,必须运行到线程卡处的线程将被减一</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>result_chunk <span class="token function">process</span><span class="token punctuation">(</span>data_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>data_chunk<span class="token operator">&gt;</span> <span class="token function">divide_into_chunks</span><span class="token punctuation">(</span>data_block data<span class="token punctuation">,</span><span class="token keyword keyword-unsigned">unsigned</span> chunk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span>data_block data<span class="token punctuation">,</span>data_sink <span class="token operator">&amp;</span>sink<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> concurrency <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> num_tasks <span class="token operator">=</span> <span class="token punctuation">(</span>concurrency <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span> concurrency <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>barrier <span class="token function">sync</span><span class="token punctuation">(</span>num_tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>joining_thread<span class="token operator">&gt;</span> <span class="token function">threads</span><span class="token punctuation">(</span>num_tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>data_chunk<span class="token operator">&gt;</span> chunks<span class="token punctuation">;</span>
    result_block results<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">joining_thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>source<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    data_block current_block<span class="token operator">=</span>source<span class="token punctuation">.</span><span class="token function">get_next_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    chunks<span class="token operator">=</span><span class="token function">divide_into_chunks</span><span class="token punctuation">(</span>current_block<span class="token punctuation">,</span>num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                sync<span class="token punctuation">.</span><span class="token function">arrive_and_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                result<span class="token punctuation">.</span><span class="token function">set_chunk</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>num_threads<span class="token punctuation">,</span><span class="token function">process</span><span class="token punctuation">(</span>chunks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sync<span class="token punctuation">.</span><span class="token function">arrive_and_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    sink<span class="token punctuation">.</span><span class="token function">write_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="stdexperimentalflex_barrier">std::experimental::flex_barrier </h4>
<p>flex_barrier相比于barrier,还接受补全函数<br>
只要全部线程都运行到线程卡处,该函数就会在其中一个线程上运行,它不但提供了机制,可以设定后续代码,令其必须按串行方式运行<br>
还给出了方法,用于改变下一同步周期必须到达该处的线程数目,</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span>data_block data<span class="token punctuation">,</span>data_sink <span class="token operator">&amp;</span> sink<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> concurrency <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> num_threads <span class="token operator">=</span> <span class="token punctuation">(</span>concurrency<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span>concurrency<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>data_chunk<span class="token operator">&gt;</span>chunks<span class="token punctuation">;</span>
    <span class="token keyword keyword-auto">auto</span> split_source<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>source<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            data_block current_block<span class="token operator">=</span>source<span class="token punctuation">.</span><span class="token function">get_next_data_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            chunks<span class="token operator">=</span><span class="token function">divide_into_chunks</span><span class="token punctuation">(</span>current_block<span class="token punctuation">,</span>num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">split_source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result_block results<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>experimental<span class="token double-colon punctuation">::</span>flex_barrier <span class="token function">sync</span><span class="token punctuation">(</span>num_threads<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
        sink<span class="token punctuation">.</span><span class="token function">write_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">split_source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>joining_thread<span class="token operator">&gt;</span><span class="token function">threads</span><span class="token punctuation">(</span>num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">joining_thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>source<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                result<span class="token punctuation">.</span><span class="token function">set_chunk</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>num_threads<span class="token punctuation">,</span><span class="token function">process</span><span class="token punctuation">(</span>chunks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                sync<span class="token punctuation">.</span><span class="token function">arrive_and_wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>std::experimental::flex_barrier 允许用户以一个函数对象控制完成阶段。若函数对象返回 -1，则不更改参与线程集合（而下个循环中同一参与线程集合必须抵达同步点）；否则参与线程集合变为拥有等于返回值 N 的新大小的集合，并由到达屏障同步点的下 N 个线程组成。</p>
<h2 id="c内存模型和原子操作">c++内存模型和原子操作 </h2>
<p>原子操作是不可分割的操作,在系统的任一线程内,我们都不会观察到这种操作属于半完成状态</p>
<p>对于原子类型的上的每一种操作，可以提供额外的参数,从枚举类std::memory_order中取值</p>
<p>操作的类别决定了内存次序所准许的取值,若没有显示调用内存显示顺序,则默认使用最严<br>
格的内存顺序,即std::memory_order_seq_cst</p>
<p>操作划分为三类:</p>
<ol>
<li>存储操作:可选用的内存次序有std::memory_order_relaxed,std::memory_order_release或std::memory_order_seq_cst</li>
<li>载入操作:std::memory_order_relaxed,std::memory_order_consume，std::memory_order_acquire或std::memory_order_seq_cst</li>
<li>度改写操作:std::memory_order_relaxed,std::memory_order_consume,std::memory_order_acquire，std::memory_order_release或std::memory_order_seq_cst</li>
</ol>
<h4 id="stdatomic_flag">std::atomic_flag </h4>
<p>是最简单的标准原子类型,表示一个布尔标志,该类型的对象只有两种状态成立或置零</p>
<p>std::atomic_flag类型的对象必须由宏ATOMIC_FLAG_INIT初始化</p>
<p>初始化后只能执行三种操作:</p>
<ol>
<li>test_and_set()</li>
<li>clear()</li>
<li>析构销毁</li>
</ol>
<p>clear是存储操作,test_and_set是读改写操作</p>
<p>上面的代码中,clear()的调用显示地采用释放语义将标志清零</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>f<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> x<span class="token operator">=</span>f<span class="token punctuation">.</span><span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>由于原子类型的操作都是原子化的,但拷贝赋值和拷贝构造都涉及两个对象<br>
,而牵涉两个不同对象的单一操作却无法原子化,在拷贝构造或拷贝赋值的过程中,必须先从来源对象读取值,再将其写出到目标对象,这是在两个独立对象上的两个独立操作,其组合不可能是原子化的<br>
所以原子对象禁止拷贝赋值和拷贝构造</p>
<p>采用std::atomic_flag实现自旋锁互斥</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">spinlock_mutex</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic_flag flag<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">spinlock_mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">flag</span><span class="token punctuation">(</span>ATOMIC_FLAG_INIT<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        flag<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="stdatomicbool">std::atomic<bool> </bool></h4>
<p>该类型的实例能接受非原子布尔量的赋值</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
<span class="token keyword keyword-bool">bool</span> x<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_oreder_acq_rel<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>比较交换操作给定一个期望值,原子变量将它和自身比较,如果相等,就存入另一既定的值,否则更新期望值所属变量,向它赋予原子变量的值<br>
原子值与期望值相等返回true,否则返回false<br>
对于compare_exchange_weak(),即使原子变量的值等于期望值<br>
保存动作仍有可能失败,在这种情形下,原子变量维持原值不变,compare_exchange_weak()返回false<br>
由于操作中途因系统调度切出导致操作失败成为佯败<br>
compare_exchange_weak()可能发生佯败,所以往往使用循环</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-bool">bool</span> expected <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword keyword-extern">extern</span> atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
<span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">!</span>expected<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>只要expected变量还是false,就说明compare_exchange_weak()的调用发生佯败继续循环</p>
<p>比较交换函数可以接受两个内存次序参数,这使程序能够区分成功和失败<br>
两种情况,采用不同的内存次序<br>
合适的做法是:若操作成功,就采用std::memory_order_acq_rel内存次序<br>
否则改用std::memory_order_relaxed内存次序<br>
失败操作设定的内存次序不能比成功操作的更严格,若将失败操作的内存次序指定为std::memory_order_acquire或std::memory_order_seq_cst</p>
<h4 id="stdatomict-算术类型的指针运算">std::atomic&lt;T*&gt; 算术类型的指针运算 </h4>
<p>fetch_add()等都是读改写操作,进行计算返回旧值</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Foo some_array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>Foo<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>some_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ptr<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>对于这些操作符的重载,总是服从std::memory_order_seq_cst内存次序</p>
<h4 id="泛化stdatomic类模板">泛化std::atomic&lt;&gt;类模板 </h4>
<p>对于自定义类型UDT,其原子化类型就是std::atomic<udt><br>
所提供的接口与std::atomic<t>相同<br>
不同之处在于函数中凡是涉及该类原子对象所表示的值,它的参数和返回值就要改成UDT类型</t></udt></p>
<p>对于某个自定义类型UDT,其原子化类型需要具备平实拷贝赋值操作符<br>
不含有任何虚函数,也不可以从虚基类派生出来,还必须由编译器代其隐式生成拷贝赋值操作符<br>
另外,若定义类型具有基类或非静态数据,则其同样需要具备平时拷贝操作符</p>
<p>编译器借用memcpy()函数实现平实拷贝赋值操作符<br>
比较交换操作符采用的是逐位比较,效果等同于memcmp()函数</p>
<p>如果自定义类型含有填充位,却不参与普通比较操作,那么即使UDT对象的值相等<br>
比较-交换操作还是会失败</p>
<h3 id="同步操作和强制顺序">同步操作和强制顺序 </h3>
<h4 id="同步关系">同步关系 </h4>
<p>基本思想:对变量x执行原子写操作W和原子读操作R，且两者都有适当的标记,只要满足下面其中一点,它们彼此同步</p>
<ol>
<li>R读取了W直接存入的值</li>
<li>W所属线程随后还执行了另一原子写操作,R读取了后面存入的值</li>
<li>任意线程执行一连串读改写操作,其中第一个操作读取的值都是W写的数据</li>
</ol>
<h4 id="先行关系">先行关系 </h4>
<p>先行关系和严格先行关系是清楚界定哪些操作呢能够顾看见其他哪些操作产生的结果</p>
<p>原子操作虽然有6种内存次序，但仅代表三种模式:</p>
<ol>
<li>先后一致次序:memory_order_seq_cst</li>
<li>获取-释放次序:memory_order_acquire,memory_order_release,memory_order_acq_rel<br>
memory_order_consume</li>
<li>宽松次序:memory_order_relaxed</li>
</ol>
<h5 id="先后一致顺序">先后一致顺序 </h5>
<p>如果在一个线程内,某项操作优先于另一项发生,那么其他线程所见的先后次序都必须如此<br>
为了保持绝对先后一致,所有线程都必须采用保序原子操作<br>
顺序一致性均保证所有线程的执行语句全局一致，不会存在重排。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_seq_cst<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>write_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>write_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>read_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t4</span><span class="token punctuation">(</span>read_y_then_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"z = "</span><span class="token operator">&lt;&lt;</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>关于上述代码利用上述解释可参考如下：</p>
<ol>
<li>首先随机选择一个线程b执行，此时y为true</li>
<li>随机选择下一个线程a执行，此时x为true</li>
<li>随机选择c线程执行，z为1</li>
<li>随机选择d执行，z为2<br>
这个过程是全局一致的，因此最后z为2</li>
</ol>
<p>或者上述也可能存在其他的顺序，譬如：</p>
<ol>
<li>随机选择线程c执行，此时x为false，线程c一直循环</li>
<li>随机选择线程d执行，此时y为fasle，线程d一直循环</li>
<li>随机选择线程a执行，此时x为true</li>
<li>随机选择线程c执行，此时y为false，x为true，z为0</li>
<li>随机选择线程b执行，此时y为true，x为true</li>
<li>随机选择线程d执行，此时z为1</li>
</ol>
<h5 id="非先后一致顺序">非先后一致顺序 </h5>
<p>在不同的cpu缓存和内部缓冲中,同一份内存数据可能具有不同的值</p>
<h5 id="宽松次序">宽松次序 </h5>
<p>原子类型上的操作不存在同步关系<br>
宽松原子操作几乎不要求服从任何次序</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    y<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>write_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>read_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z="</span> <span class="token operator">&lt;&lt;</span> z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>此时断言可能发生报错</p>
<p>多个线程上的宽松原子操作</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> loop_count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">read_values</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

read_values values<span class="token punctuation">[</span>loop_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
read_values values2<span class="token punctuation">[</span>loop_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
read_values values3<span class="token punctuation">[</span>loop_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
read_values values4<span class="token punctuation">[</span>loop_count<span class="token punctuation">]</span><span class="token punctuation">;</span>
read_values values5<span class="token punctuation">[</span>loop_count<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">increment</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token operator">*</span> var_to_inc<span class="token punctuation">,</span>read_values<span class="token operator">*</span> values<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>go<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        var_to_inc<span class="token operator">-&gt;</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_vals</span><span class="token punctuation">(</span>read_values<span class="token operator">*</span> values<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>go<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 允许其他线程推送工作到队列</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">print</span><span class="token punctuation">(</span>read_values<span class="token operator">*</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> loop_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>increment<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>increment<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">,</span> values2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>increment<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> values3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t4</span><span class="token punctuation">(</span>read_vals<span class="token punctuation">,</span> values4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t5</span><span class="token punctuation">(</span>read_vals<span class="token punctuation">,</span> values5<span class="token punctuation">)</span><span class="token punctuation">;</span>

    go <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t5<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">print</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>values2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>values3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>values4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>values5<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>运用获取-释放次序,它避免了绝对先后一致次序的额外开销</p>
<h5 id="获取-释放顺序">获取-释放顺序 </h5>
<p>其比宽松顺序严格一点可以产生一定程度的同步而不会形成服从先后一致次序的全局总操作序列</p>
<p>该模型中:原子化载入为获取操作<br>
原子化存储为释放操作，而原子化读改写则为获取或释放操作</p>
<p>这种内存次序在成对的读写线程之间起到同步作用<br>
释放与获取操作构成同步关系，前者写出的值由后者读取</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码中y的写与读相同步<br>
此时由于x的写入先于y<br>
所以y的读操作后再进行x的读操作一定成功<br>
所以此处z的结果为1</p>
<p>但如果上面y的载入操作没放在while循环中,y的载入可能为false此时x则不再确定<br>
获取和释放操作成对时才可以产生同步</p>
<p>运用获取释放次序传递同步</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span>data<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">sync1</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sync2</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">thread_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sync1<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">thread_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sync1<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sync2<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

viid <span class="token function">thread_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sync2<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>尽管thread_2只接触过sync1和sync2,但这足以同步线程thread_1和thread_3,从而保证每个断言都不会触发</p>
<p>上例中,我们还能进一步将变量sync1和sync2融合成单一变量,在线程thread_2上对其执行"读-改-写"操作<br>
该操作采用memory_order_acq_rel次序</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">thread_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">thread_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token comment">//  原子的比较 *this  和 expect的值，若它们逐位相等，则以 desired 替换前者（进行读修改写操作）。否则，将 *this 中的实际值加载进 expected （进行加载操作）。</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sync<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_acq_rel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    expected <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">thread_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>sync<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><h5 id="获取-释放次序和memory_order_consume">获取-释放次序和memory_order_consume </h5>
<p>这种内存次序可以按原子化方式载入某份数据的指针,我们把存储操作设定成memory_order_release次序<br>
而将后面的读取操作设定为memory_order_consume次序</p>
<p>即可保证所指向的目标数据得到正确同步而无须对任何非独立数据施加同步措施</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>X<span class="token operator">*</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">create_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    X<span class="token operator">*</span> x<span class="token operator">=</span><span class="token keyword keyword-new">new</span> X<span class="token punctuation">;</span>
    x<span class="token operator">-&gt;</span>i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
    x<span class="token operator">-&gt;</span>s<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">use_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    X<span class="token operator">*</span> x<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_consume<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>i<span class="token operator">==</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>s<span class="token operator">==</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><p>上述代码结构的意义在于保证指针p的载入操作接受判别表达式带来依赖,<br>
因此两个断言肯定都不会触发<br>
而a的断言可能会触发</p>
<p>若代码有大量携带依赖,则会造成额外开销,我们并不想编译器面对依赖而束手无策<br>
而希望它将值缓存在CPU寄存器中,并重新编排指令进行优化</p>
<p>这时,我们可以用std::kill_dependency()显式打断依赖链,假设有一个只读的全局数组<br>
其索引值由其他线程给出,而我们采用std::memory_order_consume次序接受该值<br>
那么可以用std::kill_dependency()告知编译器,无须重复读数组元素</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-int">int</span> global_data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> index<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_consume<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_something_with</span><span class="token punctuation">(</span>global_data<span class="token punctuation">[</span>std<span class="token double-colon punctuation">::</span><span class="token function">kill_dependency</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>如果存储操作的标记是memory_order_release,memory_order_acq_rel或memory<br>
_order_seq_cst,而载入操作则以memory_order_consume,memory_order_acquire或memory_order_seq_cst<br>
标记,那么操作链由一个释放序列组成<br>
</strong><br>
<strong>若最后载入操作服从内存次序memory_order_acquire或memory_order_seq_cst与它构成同步关系,但如果该载入操作服从的内存次序是memory_order_consume那么两者构成前序依赖关系,操作链中,每个"读-改-写"操作都可以选用任意内存次序,甚至也能选用memory_order_relaxed次序<br>
</strong></p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> <span class="token function">count</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> queue_data<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">populate_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> number_of_items <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    queue_data<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>number_of_items<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        queue_data<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    count<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>number_of_items<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">consume_queue_items</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-int">int</span> item_index<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item_index<span class="token operator">=</span>count<span class="token punctuation">.</span><span class="token function">fetch_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>queue_data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Consumed item: "</span><span class="token operator">&lt;&lt;</span>queue_data<span class="token punctuation">[</span>item_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>populate_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>consume_queue_items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>consume_queue_items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span>
</code></pre><p>count.fetch_sub(1,std::memory_order_acquire)表示向其他线程告知它会从容器取出一项数据,然后才真正读取共享缓冲,一旦计数值为0,即再无数据项可取,消费线程必须就此等待</p>
<p>上述代码中两个线程进行取操作,除非前一个线程也采用memory_order_release，但这样的同步过于严格</p>
<h3 id="栅栏">栅栏 </h3>
<p>栅栏具备多种操作,用途是强制施加内存次序<br>
却无需改动任何数据<br>
通常,它们与服从memory_order_relaxed次序的原子操作组合使用。栅栏操作全部通过全局函数执行。<br>
当线程运行至栅栏处时,它便会对线程中其他原子操作的次序产生作用,栅栏也常常被称作内存卡,或内存屏障,原因是它们在代码中划出界限,限定某些操作不得通行<br>
在一个多线程程序中，可能原来并非处处具备先行关系和同步关系,栅栏则在欠缺之处引入这两种关系</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    y<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">a</span><span class="token punctuation">(</span>write_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">b</span><span class="token punctuation">(</span>read_y_then_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z="</span> <span class="token operator">&lt;&lt;</span> z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的例子通过加入栅栏实现了同步<br>
加入栅栏使存储操作不再服从memory_order_relaxed次序,而是以memory_order_release次序进行,<br>
而读取操作则以memory_order_acquire次序进行,这样就能确保读取操作先于写入操作进行,从而实现同步</p>
<p>尽管栅栏是让读写同步,但同步点是栅栏本身</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>栅栏不再前后分隔这两个写出操作,因此它们之间原来的先后次序不复存在,栅栏只有放置在变量x和y的存储操作之间,才会强制这两个操作服从先后次序</p>
<h3 id="凭借原子操作令非原子操作服从内存次序">凭借原子操作令非原子操作服从内存次序 </h3>
<p>向非原子操作强制施行内存次序</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword keyword-bool">bool</span> x<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> y<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> z<span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">write_x_then_y</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">read_y_then_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">atomic_thread_fence</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">++</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    x<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    y<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    z<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">a</span><span class="token punctuation">(</span>write_x_then_y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">b</span><span class="token punctuation">(</span>read_y_then_x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"z="</span><span class="token operator">&lt;&lt;</span>z<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h5 id="强制非原子操作服从内存次序">强制非原子操作服从内存次序 </h5>
<p>lock()实现方式是在循环中反复调用flag.text_and_set()，其中所采用的次序为std::memory_order_acquire,unlock()<br>
实质上是服从std::memory_order_release次序<br>
的flag.clear()操作,第一个线程调用lock()时,标志flag处于置零状态,test_and_set()第一次调用会设置标志成立并返回false,表示负责执行的线程已获取了锁,遂循环结束,互斥随即生效,该线程可修改受其保护的数据而不受干扰,此时标志已设置成立,如果任何其他线程再调用lock()，都会在test_and_set()所在循环中阻塞</p>
<p>当持锁线程完成了受保护数据的改动,就调用unlock(),再进一步按std::memory_order_release次序语义执行了flag.clear()<br>
若第二个线程因调用了lock()而反复执行flag.test_and_set(),又因该操作采用了std::memory_order_acquire次序语义,故标志上的这两项操作形成同步,根据互斥的使用规则,首先,受保护数据的改动须按流程顺序在调用 unlock()前完成,其次只有在解锁以后才能重新加锁；最后，第二个线程需要先获取锁,接着才可以访问目标数据,所以,改动先于unlock()发生,自然也先于第二个线程的lock()调用,进而更加先于第二个线程数据访问</p>
<p>前面章节介绍的同步机制如下:</p>
<ol>
<li>
<p>std::thread<br>
如果我们给出一个函数或可调用对象,凭借构造std::thread实例创建新线程并由它执行,那么该实例的构造函数的完成与前者的调用形成同步<br>
若管控线程的std::thread对象上执行了join调用,而此函数返回成功,则该线程的运行完成与这一返回动作同步</p>
</li>
<li>
<p>std::mutex,std::timed_mutex,std::recursive_mutex和std::recursive_timed_mutex<br>
给定一互斥对象,其上的lock()和unlock()的全部调用,以及try_lock()，try_lock_for()和try_lock_until()的调用会形成单一总序列,即对该互斥进行加锁和解锁的操作序列</p>
</li>
</ol>
<p>给定一互斥对象,其上的lock()和unlock()的全部调用,以及try_lock(),try_lock_for()和try_lock_until()的成功调用会形成单一总序列,即对该互斥进行加锁和解锁的操作序列<br>
给定一互斥对象,在其加锁和解锁的操作序列中，每个unlock()调用都与下一个lock()调用同步,或与下一个try_lock(),try_lock_for()或try_lock_until()的调用失败,则不构成同步关系</p>
<ol start="3">
<li>std::shared_mutex,std::shared_timed_mutex<br>
给定一互斥对象,其上的lock(),unlock(),lock_shared()和unshared_shared()的全部调用以及try_lock(),try_lock_for()和try_lock_shared_until()的成功调用会形成单一总序列,即对该沪指进行加锁和解锁的操作序列</li>
</ol>
<p>给定一互斥对象,在其加锁和解锁的操作序列中,每个unlock()调用都与下一个lock()调用同步,或与下一个try_lock(),try_lock_for(),try_lock_until(),try_lock_shared()或try_lock_shared_for()的成功调用同步,但如果调用失败则不构成任何同步关系</p>
<ol start="4">
<li>std::promise,std::future,std::shared_future<br>
给定一std::promise对象,则我们由get_future()得到关联的std::future对象,我们共享异步状态,如果std::promise上的set_value()或set_exception()调用成功,又如果我们接着在该std::future对象上调用wait()或get(),wait_for()或wait_until()，成功返回std::future_status::ready,那么这两次调用的成功返回构成同步</li>
</ol>
<p>给定一std::promise对象,则我们由get_future()得到关联的std::future对象,它们共享异步状态,如果出现异常,该异步状态就会存储一个std::future_error异常对象,又如果我们在关联的std::future对象上调用wait()...成功返回std::future_status::ready，那么std::promise对象的析构函数与该成功返回构成同步</p>
<ol start="5">
<li>std::packaged_task,std::future和std::shared_future<br>
给定一std::packaged_task对象,则我们由get_future()得到关联的std::future对象,它们共享异步状态,如果包装的任务由std::packaged_task的函数调用操作符运行,我们关联的std::future对象上调用wait(),get(),wait_for()或wait_until()成功返回std::future_status::ready,那么这两次调用的成功返回构成同步</li>
</ol>
<p>给定一std::packaged_task对象,则我们由get_future()得到关联的std::future对象,它们共享异步状态,如果包装的任务抛出异常,该异步状态就会存储一个std::future_error异常对象,又如果我们在关联的std::future对象上调用wait()...成功返回std::future_status::ready,那么std::packaged_task对象的析构函数与该成功返回构成同步</p>
<ol start="6">
<li>std::async，std::future和std::shared_futrure,如果一项任务通过调用std::launch::async方式在其他线程上异步运行,则该std::async调用会生成一个关联的std::future对象,它与启动的任务共享异步状态,若我们在该std::future对象上调用wait(),get()，wait_for()或wait_until()成功返回std::future_status::ready,那么任务的完成与该任务成功返回构成同步</li>
</ol>
<p>如果以std::launch::deferred方式启动的任务,则该任务的运行与std::async调用的返回同步,若任务的运行完成,则该任务的结果与std::future对象上调用wait(),get()，wait_for()或wait_until()的成功返回同步,若任务抛出异常,则该异常与std::future对象上调用wait(),get()，wait_for()或wait_until()的异常返回同步</p>
<ol start="7">
<li>
<p>std::experimental::future，std::experimental::shared_future和后续函数<br>
异步共享状态会因目标事件触发而变成就绪,共享状态上所编排的后续函数也随之运行,该事件与后续函数的启动构成同步，在起始future上调用then来编排后续函数,并由此生成另一个std::future对象,它与起始future共享异步状态,若我们在该新std::future对象上调用wait(),get(),wait_For()或wait_until(),成功返回std::future_status::ready那么后续函数的完成会与该成功返回构成同步,或与所编排的下一个后续函数的启动构成同步</p>
</li>
<li>
<p>std::latch 若在其上调用count_down(),或count_down_and_wait()，则每次调用的启动都与其自身的完成同步</p>
</li>
<li>
<p>std::barrier 若在其上调用arrive_and_wait()或arrive_and_drop(),则每次调用的启动都与其自身的完成同步</p>
</li>
<li>
<p>std::experimental::flex_barrier：给定一std::experimental::flex_barrier实例,若在其上调用arrive_and_wait()或arrive_and_drop(),则每次调用的启动都与其下一次arrive_and_wait()运行完成同步<br>
给定一 std::experimental::flex_barrier实例,若在其上调用wait()或wait_for()或wait_until(),则每次调用的启动都与其补全函数的全部启动完成同步<br>
给定一 std::experimental::flex_barrier实例,若在其上调用arrive_and_drop(),则这些调用会因等待补全函数的完成而发生阻塞,而补全函数的返回与这些调用的完成构成同步</p>
</li>
<li>
<p>std::condition_variable和std::condition_variable_any<br>
条件变量并不提供任何同步关系,它们本质上是忙碌等循环的优化,其所有同步功能都由关联的互斥提供</p>
</li>
</ol>
<h2 id="设计基于锁的并发数据结构">设计基于锁的并发数据结构 </h2>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREADSAFE_QUEUE_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREADSAFE_QUEUE_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_queue</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex mut<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data_queue<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>condition_variable data_cond<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> <span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> <span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// THREADSAFE_QUEUE_HPP</span></span>

</code></pre><p>本例与栈容器有所不同:假定在数据入队的过程中,有多个线程同时在等待,那么data_cond.notify_one()的调用只会唤醒一个,然而若该觉醒的线程在wait_and_pop()时抛出异常,就不会有任何其他线程被唤醒,如果希望所有等待线程都被唤醒,使用data_cond.notify_all()即可，但会大大增加开销<br>
改善方法是为了不抛出异常,队列容器改为存储std::shared_ptr&lt;&gt;</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREADSAFE_QUEUE_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREADSAFE_QUEUE_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_queue</span> 
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex mut<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> data_queue<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>condition_variable data_cond<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token keyword keyword-this">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> <span class="token operator">!</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> res <span class="token operator">=</span> data_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>mut<span class="token punctuation">)</span><span class="token punctuation">;</span>        
            <span class="token keyword keyword-return">return</span> data_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// THREADSAFE_QUEUE_HPP</span></span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREAD_SAFE_STACK_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SAFE_STACK_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stack&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;exception&gt;</span></span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">empty_stack</span><span class="token operator">:</span><span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">exception</span></span><span class="token punctuation">{</span>
    <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-char">char</span><span class="token operator">*</span> <span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span> <span class="token keyword keyword-throw">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_stack</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>stack<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> stack<span class="token punctuation">;</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">threadsafe_stack</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_stack<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data <span class="token operator">=</span> other<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        threadsafe_stack<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_stack<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-throw">throw</span> <span class="token function">empty_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword keyword-throw">throw</span> <span class="token function">empty_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            data<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// THREAD_SAFE_STACK_HPP</span></span>
</code></pre><h4 id="采用细粒度的锁和条件变量实现线程安全的队列容器">采用细粒度的锁和条件变量实现线程安全的队列容器 </h4>
<p>单线程队列的简单实现</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            T data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span>next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span>T data_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
        node<span class="token operator">*</span> tail<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">tail</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">queue</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> queue<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> <span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                tail <span class="token operator">=</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token function">node</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_tail <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span>
            <span class="token punctuation">{</span>
                head<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tail <span class="token operator">=</span> new_tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ol>
<li>
<p>通过分离数据而实现并发<br>
我们可以预先设置一个不含数据的虚位节点<br>
从而保证至少存在一个节点,以区别头尾两个节点的访问,如果队列为空,head和tail两个指针都不再是NULL值,而是同时指向虚位节点<br>
若我们向队列添加数据,则head和tail指针会分别指向不同的节点,在head-&gt;next和tail-&gt;next上不会出现竞争,但其缺点是,为了容纳虚位节点,我们需要通过指针间接存储数据,额外增加了一个访问层级</p>
<p>带有虚位节点的简单队列</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">queue</span>
<span class="token punctuation">{</span>
 <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
     <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
     <span class="token punctuation">{</span>
         std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
         std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span>next<span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
     std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
     node<span class="token operator">*</span> tail<span class="token punctuation">;</span>
 <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
     <span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     queue<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
     queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> queue<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
     std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>tail<span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> <span class="token function">res</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
         std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
         head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
         tail<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
         node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_tail <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
         tail <span class="token operator">=</span> new_tail<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>引入虚位节点,head指针不再取值NULL,改为比较head和tail是否重叠</p>
<p>push只访问tail指针而不再触及head指针，虽然try_pop()既访问head指针又访问tail指针,但tail指针只用于函数中最开始的比较运算，所以只需短暂持锁</p>
<p>push在新节点创建完成就锁住,在数据赋予当前尾节点之前也要锁住互斥<br>
try_pop首先需要为head锁住互斥并一直持锁,等待使用完再解锁，余下只有tail<br>
需要在对应的互斥上加锁,最好在临近访问再加锁,所以可以将加锁和访问封装成一个函数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREAD_SAFE_QUEUE_FINEGRAIN_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SAFE_QUEUE_FINEGRAIN_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex head_mutex<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex tail_mutex<span class="token punctuation">;</span>
        node<span class="token operator">*</span> tail<span class="token punctuation">;</span>
        node<span class="token operator">*</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">tail_lock</span><span class="token punctuation">(</span>tail_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span><span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span>head_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> old_head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        threadsafe_queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token punctuation">,</span>node<span class="token operator">&gt;</span> old_head <span class="token operator">=</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword keyword-return">return</span> old_head <span class="token operator">?</span> old_head<span class="token operator">-&gt;</span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">new_node</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_tail <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">tail_lock</span><span class="token punctuation">(</span>tail_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            tail<span class="token operator">-&gt;</span>data <span class="token operator">=</span> new_data<span class="token punctuation">;</span>
            tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
            tail <span class="token operator">=</span> new_tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREADSAFE_QUEUE_WAIT_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREADSAFE_QUEUE_WAIT_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex head_mutex<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>mutex tail_mutex<span class="token punctuation">;</span>
        node<span class="token operator">*</span> tail<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>condition_variable data_cond<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">threadsafe_queue</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_queue<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        threadsafe_queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> threadsafe_queue<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">wait_and_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        node<span class="token operator">*</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">tail_lock</span><span class="token punctuation">(</span>tail_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> tail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_head<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            head <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> old_head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">wait_for_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span>head_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            data_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>head_lock<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>head_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">wait_pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span><span class="token function">wait_for_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">wait_pop_head</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span><span class="token function">wait_for_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">try_pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span>head_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>node<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">try_pop_head</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span>head_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>node<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            value <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">tail_lock</span><span class="token punctuation">(</span>tail_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail<span class="token operator">-&gt;</span>data <span class="token operator">=</span> new_data<span class="token punctuation">;</span>
        tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_tail <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail <span class="token operator">=</span> new_tail<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    data_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">wait_and_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> old_head <span class="token operator">=</span> <span class="token function">wait_pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> old_head<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">wait_and_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_head <span class="token operator">=</span> <span class="token function">wait_pop_head</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">try_pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> old_head <span class="token operator">=</span> <span class="token function">try_pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> old_head<span class="token operator">?</span> old_head<span class="token operator">-&gt;</span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">try_pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span> old_head <span class="token operator">=</span> <span class="token function">try_pop_head</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> old_head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-bool">bool</span> <span class="token class-name">threadsafe_queue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">head_lock</span><span class="token punctuation">(</span>head_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> head<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">get_tail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>



<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// THREADSAFE_QUEUE_WAIT_HPP</span></span>
</code></pre><h3 id="设计更复杂的基于锁的并发数据结构">设计更复杂的基于锁的并发数据结构 </h3>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREADSAFE_LIST_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREADSAFE_LIST_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hash_map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">threadsafe_list</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
        <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    node head<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span> 
        <span class="token function">threadsafe_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token operator">~</span><span class="token function">threadsafe_list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">remove_if</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>node <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">threadsafe_list</span><span class="token punctuation">(</span>threadsafe_list <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span>delele<span class="token punctuation">;</span>
        threadsafe_list<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>threadsafe_list <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Function</span><span class="token operator">&gt;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">for_each</span><span class="token punctuation">(</span>Function f<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> current<span class="token operator">=</span><span class="token operator">&amp;</span>head<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> next<span class="token operator">=</span>current<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">next_lk</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                current<span class="token operator">=</span>next<span class="token punctuation">;</span>
                lk <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>next_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Predicate</span><span class="token operator">&gt;</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">find_first_if</span><span class="token punctuation">(</span>Predicate p<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> current <span class="token operator">=</span><span class="token operator">&amp;</span>head<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> next<span class="token operator">=</span>current<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">next_lk</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">*</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword keyword-return">return</span> next<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                current<span class="token operator">=</span>next<span class="token punctuation">;</span>
                lk <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>next_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Predicate</span><span class="token operator">&gt;</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">remove_if</span><span class="token punctuation">(</span>Predicate p<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> current<span class="token operator">=</span><span class="token operator">&amp;</span>head<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> next<span class="token operator">=</span> current<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">next_lk</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">*</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">next_lk</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">*</span>next<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        current<span class="token operator">-&gt;</span>next <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        next_lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword keyword-else">else</span> 
                    <span class="token punctuation">{</span>
                        lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        current <span class="token operator">=</span> next<span class="token punctuation">;</span>
                        lk <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>next_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// THREADSAFE_LIST_HPP</span></span>
</code></pre><h2 id="设计无锁数据结构">设计无锁数据结构 </h2>
<p>算法和数据结构中只要采用了互斥,条件变量或future进行同步操作,就称之为阻塞型算法和阻塞型数据结构,如果应用程序调用某些库函数,发起调用的线程便会暂停运行,即在函数的调用点阻塞,等到另一线程完成某项相关操作,阻塞才会解除,前者才会继续运行。<br>
这些库函数的调用被命名为阻塞型调用,操作系统往往会把被阻塞的线程彻底暂停,并将其时间片分给其他线程,等到有线程执行了恰当的操作,阻塞方被解除,恰当的操作可能是释放互斥,知会条件变量,或是未future对象装填结果值而令其就绪</p>
<p>没有采用上述阻塞型库函数的调用的称为非阻塞型算法和非阻塞型数据结构</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">spinlock_mutex</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic_flag flag<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">spinlock_mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">flag</span><span class="token punctuation">(</span>ATOMIC_FLAG_INIT<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-void">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        flag<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>实践中,我们需要参考下列详细定义,根据适用的条款,分辨该型别/函数属于哪一类</p>
<ol>
<li>无阻碍:假定其他线程全部暂停,则目标线程将在有限步骤内完成自己的操作</li>
<li>无锁:如果多个线程共同操作同一份数据,那么在有限步骤内,其中某一线程能够完成自己的操作</li>
<li>免等:在某份数据上,每个线程经过有限步骤就能完成自己的操作,即便该份数据同时被其他多个线程操作</li>
</ol>
<h3 id="无需等待的数据结构">无需等待的数据结构 </h3>
<p>如果它被多个线程访问,不论其他线程上发生什么,每个线程都能在有限步骤内完成自己的操作,<br>
若多个线程之间存在冲突,导致某算法无限制的反复尝试执行操作,那它就是免等算法</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LOCK_FREE_STACK_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOCK_FREE_STACK_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_stack</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            T data<span class="token punctuation">;</span>
            node<span class="token operator">*</span> next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> T<span class="token operator">&amp;</span> data_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_node <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new_node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//首先不等,new_node-&gt;next = head;然后相等head=new_node，退出循环</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> result<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token operator">=</span>old_head<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token comment">//一旦比较交换操作成功,说明只有当前线程在改动栈容器,从栈顶弹出节点</span>
        <span class="token comment">//该段代码未处理空栈情况,以及安全异常处理</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_stack_sptr</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
        node<span class="token operator">*</span> next<span class="token punctuation">;</span>
        <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> new_node <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new_node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>old_head <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> old_head<span class="token operator">?</span> old_head<span class="token operator">-&gt;</span>data <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//这段代码虽然是无锁实现,却非免等实现,原因在于若compare_exchange_weak()的结果总是false,理论上会导致push()和pop()中的while循环持续进行</span>
    <span class="token comment">//只有等到没有线程调用pop()时才删除链表中的节点</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">&gt;</span> to_be_deleted<span class="token punctuation">;</span>
        <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">delete_nodes</span><span class="token punctuation">(</span>node<span class="token operator">*</span> nodes<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                node<span class="token operator">*</span> next <span class="token operator">=</span> nodes<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                <span class="token keyword keyword-delete">delete</span> nodes<span class="token punctuation">;</span>
                nodes <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">try_reclaim</span><span class="token punctuation">(</span>node<span class="token operator">*</span> old_head<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>threads_in_pop<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                node<span class="token operator">*</span> nodes_to_delete <span class="token operator">=</span> to_be_deleted<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前线程把候删链表收归己有</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>threads_in_pop<span class="token punctuation">)</span><span class="token comment">//判断pop()是否仅仅正被当前线程唯一调用</span>
                <span class="token punctuation">{</span>
                    <span class="token function">delete_nodes</span><span class="token punctuation">(</span>nodes_to_delete<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>nodes_to_delete<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token function">chain_pending_nodes</span><span class="token punctuation">(</span>nodes_to_delete<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-delete">delete</span> old_head<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
                <span class="token function">chain_pending_node</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>threads_in_pop<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">chain_pending_nodes</span><span class="token punctuation">(</span>node<span class="token operator">*</span> nodes<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> last<span class="token operator">=</span>nodes<span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> next<span class="token operator">=</span>last<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                last<span class="token operator">=</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">chain_pending_nodes</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">chain_pending_nodes</span><span class="token punctuation">(</span>node<span class="token operator">*</span> first<span class="token punctuation">,</span> node<span class="token operator">*</span> last<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> to_be_deleted<span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>to_be_deleted<span class="token punctuation">.</span><span class="token function">compare_exchane_weak</span><span class="token punctuation">(</span>last<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//借循环保证last-&gt;next指向正确</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">chain_pending_node</span><span class="token punctuation">(</span>node<span class="token operator">*</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">chain_pending_nodes</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>    
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token operator">&gt;</span> threads_in_pop<span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">try_reclaim</span><span class="token punctuation">(</span>node<span class="token operator">*</span> old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop_safe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token operator">++</span>threads_in_pop<span class="token punctuation">;</span>
            node<span class="token operator">*</span> old_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>old_head<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//此处head已经指向下一个节点,所以不会有线程再访问old_head</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> res<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                res<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">try_reclaim</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//原子变量threads_in_pop记录目前正有多少线程试图从栈容器弹出数据</span>
        <span class="token comment">//它在pop()函数的最开始处自增,在try_reclaim()内部自减,每当有节点被删除,程序就调用try_reclaim()一次</span>
        <span class="token comment">//由于可能延后删除节点,所以暂时只用swap将数据置换出来,而先不删除地址</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// LOCK_FREE_STACK_HPP</span></span>
</code></pre><p>采用风险指针实现的pop()函数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>hp<span class="token operator">=</span><span class="token function">get_hazard_pointer_for_current_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span>
        node<span class="token operator">*</span> temp<span class="token operator">=</span>old_head<span class="token punctuation">;</span>
        <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span><span class="token comment">//反复循环直到风险指针被设置为head才停止</span>
            temp<span class="token operator">=</span>old_head<span class="token punctuation">;</span>
            hp<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>old_head1<span class="token operator">!=</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hp<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">outstanding_hazard_pointers_for</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span><span class="token comment">//删除旧有头结点之前,先检查它是否正在被风险指针所指涉</span>
        <span class="token comment">//若被指涉,该节点就不能马上删除,我们调用delete_nodes_with_no_hazards()，以检查reclaim_later()回收所有节点,如果其中有一些节点不再被任何指针所指涉,即可安全删除</span>
            <span class="token function">reclaim_later</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-delete">delete</span> old_head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">delete_nodes_with_no_hazards</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//get_hazard_pointer_for_current_thread()的简单实现</span>
<span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> max_hazard_pointers<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">hazard_pointer</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id<span class="token operator">&gt;</span>id<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token operator">&gt;</span> pointer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
hazard_pointer hazard_pointers<span class="token punctuation">[</span>max_hazard_pointers<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">hp_owner</span>
<span class="token punctuation">{</span>
    hazard_pointer <span class="token operator">*</span> hp<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">hp_owner</span><span class="token punctuation">(</span>hp_owner <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    hp_owner<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>hp_owner <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    <span class="token function">hp_owner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">hp</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>max_hazard_pointers<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>tread<span class="token double-colon punctuation">::</span>id old_id<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>hazard_pointers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_id<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                hp<span class="token operator">=</span><span class="token operator">&amp;</span>hazard_pointers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hp<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-throw">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"No hazard pointers available"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token function">get_pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> hp<span class="token operator">-&gt;</span>pointer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">hp_owner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        hp<span class="token operator">-&gt;</span>pointer<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hp<span class="token operator">-&gt;</span>id<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token function">get_hazard_pointer_for_current_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-thread_local">thread_local</span> <span class="token keyword keyword-static">static</span> hp_owner hazard<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> hazard<span class="token punctuation">.</span><span class="token function">get_pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-bool">bool</span> <span class="token function">outstanding_hazard_pointers_for</span><span class="token punctuation">(</span>node<span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>max_hazard_pointers<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>hazard_pointers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pointer<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>p<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//节点回收函数的一种简单实现</span>
<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">do_delete</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-delete">delete</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">data_to_reclaim</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span><span class="token operator">*</span> data<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> deleter<span class="token punctuation">;</span>
    data_to_reclaim<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    data_to_reclaim<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token function">data_to_reclaim</span><span class="token punctuation">(</span>T<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">deleter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>do_delete<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">data_to_reclaim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">deleter</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>data_to_reclaim<span class="token operator">*</span><span class="token operator">&gt;</span> nodes_to_reclaim<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">add_to_reclaim_list</span><span class="token punctuation">(</span>data_to_reclaim<span class="token operator">*</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nodes_to_reclaim<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodes_to_reclaim<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">reclaim_later</span><span class="token punctuation">(</span>T<span class="token operator">*</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">add_to_reclaim_list</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token function">data_to_reclaim</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">delete_nodes_with_no_hazards</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    data_to_reclaim <span class="token operator">*</span> current <span class="token operator">=</span> 
    nodes_to_reclaim<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        data_to_reclaim <span class="token operator">*</span> <span class="token keyword keyword-const">const</span> next <span class="token operator">=</span> current<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">outstanding_hazard_pointers_for</span><span class="token punctuation">(</span>current<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-delete">delete</span> current<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span>
        <span class="token punctuation">{</span>
            <span class="token function">add_to_reclaim_list</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        current <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_stack</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span><span class="token operator">:</span>
            <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span>
            <span class="token keyword keyword-const">const</span> new_node<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>node<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new_node<span class="token operator">-&gt;</span>next<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">atomic_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span><span class="token function">atomic_compare_exchange_weak</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>new_node<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>node<span class="token operator">&gt;</span> old_head<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">atomic_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>old_head <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>std<span class="token double-colon punctuation">::</span><span class="token function">atomic_compare_exchange_weak</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>old_head<span class="token punctuation">,</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span><span class="token function">atomic_store</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>node<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">~</span><span class="token function">lock_free_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>按分离引用计数的方式向无锁栈容器压入节点<br>
内外两个计数器之和即为节点的总引用数目<br>
外部计数器每当指针被读取时自增,内部计数器每当读取操作完成而自减</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_stack</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">counted_node_ptr</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-int">int</span> external_count<span class="token punctuation">;</span>
            node<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-int">int</span><span class="token operator">&gt;</span> internal_count<span class="token punctuation">;</span>
            counted_node_ptr next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data_<span class="token punctuation">)</span><span class="token operator">:</span>
            <span class="token function">data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>data_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">internal_count</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>counted_node_ptr<span class="token operator">&gt;</span> head<span class="token punctuation">;</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">increase_head_count</span><span class="token punctuation">(</span>counted_node_ptr<span class="token operator">&amp;</span> old_counter<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr new_counter<span class="token punctuation">;</span>
            <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span>
                new_counter <span class="token operator">=</span> old_counter<span class="token punctuation">;</span>
                <span class="token operator">++</span>new_counter<span class="token punctuation">.</span>external_count<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_counter<span class="token punctuation">,</span>new_counter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对比两个机构体,二者ptr均指向头结点,但external_count不同,判定head指针是否同时被别的线程改动过,如果两个结构体相等,就把计数器自增后的新值赋予head</span>
            old_counter<span class="token punctuation">.</span>external_count<span class="token operator">=</span>new_counter<span class="token punctuation">.</span>external_count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token operator">~</span><span class="token function">lock_free_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr new_node<span class="token punctuation">;</span>
            new_node<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword keyword-new">new</span> <span class="token function">node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new_node<span class="token punctuation">.</span>external_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
            new_node<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>next<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>new_node<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>new_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">increase_head_count</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
                node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> ptr<span class="token operator">=</span>old_head<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//若失败,则表明此时有另一线程同时弹出节点,且先于本线程完成,或有另一线程同时向栈容器压入新节点,也先于本线程完成,此时old_head指向的节点已经被其他线程删除,所以需要重新读取head指针</span>
                <span class="token punctuation">{</span>
                    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> res<span class="token punctuation">;</span>
                    res<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过swap将数据从节点中提取出来,从而确保在弹出完成后数据项无法被其他线程指涉</span>
                    <span class="token keyword keyword-int">int</span> <span class="token keyword keyword-const">const</span> count_increase<span class="token operator">=</span>old_head<span class="token punctuation">.</span>external_count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
                    <span class="token comment">//内部计数器的增量是外部计数器的旧值减2,头节点弹出栈容器，此时-1，而当前线程不再访问该节点,所以外部计数器再-1</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>ptr<span class="token operator">-&gt;</span>internal_count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span>count_increase<span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span>count_increase<span class="token punctuation">)</span><span class="token comment">//fetch_add将节点外部引用计数器的新值加到内部引用计数上,若内部引用计数值变为0,则其原值的返回值是新的外部引用计数值的相反数,遂可删除节点</span>
                    <span class="token punctuation">{</span>
                        <span class="token keyword keyword-delete">delete</span> ptr<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>ptr<span class="token operator">-&gt;</span>internal_count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//若当前线程弹出节点失败,则它不会再访问该节点,我们遂令其引用计数自减,如果当前线程试图弹出这个节点却操作失败,则它不会再访问该节点,我们就令其引用计数自减</span>
                <span class="token comment">//如果当前线程是最后一个持有指针的线程,则其内部引用计数会变为1,再减1会使计数清零所以删除节点再继续循环</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword keyword-delete">delete</span> ptr<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><p>只要我们载入head指针,就必须首先令头节点的外部引用计数自增,以表明它正在被指涉//内部计数器的增量是外部计数器的旧值减2,头节点弹出栈容器，此时-1，而当前线程不再访问该节点,所以外部计数器再-1</p>
<h4 id="实现线程安全的无锁队列">实现线程安全的无锁队列 </h4>
<p>仅能服务单一生产者和单一消费者的无锁队列</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            node<span class="token operator">*</span> next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">&gt;</span> head<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">&gt;</span> tail<span class="token punctuation">;</span>
        node<span class="token operator">*</span> <span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_head<span class="token operator">==</span>tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> <span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            head<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> old_head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">lock_free_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">tail</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">lock_free_queue</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> lock_free_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        lock_free_queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> lock_free_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        <span class="token operator">~</span><span class="token function">lock_free_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                head<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-delete">delete</span> old_head<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> old_head<span class="token operator">=</span><span class="token function">pop_head</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>old_head<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token function">res</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>old_head<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-delete">delete</span> old_head<span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> res
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token operator">*</span> p<span class="token operator">=</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">;</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> old_tail<span class="token operator">=</span>tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            old_tail<span class="token operator">-&gt;</span>data<span class="token operator">=</span>new_data<span class="token punctuation">;</span>
            old_tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
            tail<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面的代码仅支持单生产者和单消费者模式,若要支持多生产者和多消费者模式则需进一步修改</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_data</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token function">T</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    counted_node_ptr new_next<span class="token punctuation">;</span>
    new_next<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">;</span>
    new_next<span class="token punctuation">.</span>external_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> old_tail<span class="token operator">=</span> tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        T<span class="token operator">*</span> old_data<span class="token operator">=</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_tail<span class="token operator">-&gt;</span>data<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_data<span class="token punctuation">,</span>new_data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//若尾节点没有数据,则将新数据放入尾节点</span>
        <span class="token punctuation">{</span>
            old_tail<span class="token operator">-&gt;</span>next<span class="token operator">=</span>new_next<span class="token punctuation">;</span>
            tail<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>new_next<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            new_data<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>实现无锁队列的push()功能,其中对尾节点进行引用计数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">counted_node_ptr</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-int">int</span> external_count<span class="token punctuation">;</span>
            node<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>counted_node_ptr<span class="token operator">&gt;</span>head<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>counted_node_ptr<span class="token operator">&gt;</span>tail<span class="token punctuation">;</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node_counter</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-unsigned">unsigned</span> internal_count<span class="token operator">:</span><span class="token number">30</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-unsigned">unsigned</span> external_counters<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//         位域（bit field）:</span>

<span class="token comment">// 冒号（:）后面的数字表示该变量占用的位数。</span>
<span class="token comment">// internal_count:30 表示 internal_count 占用 30 位。</span>
<span class="token comment">// external_count:2 表示 external_count 占用 2 位。</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node_counter<span class="token operator">&gt;</span> count<span class="token punctuation">;</span>
            counted_node_ptr next<span class="token punctuation">;</span>
            <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                node_counter new_count<span class="token punctuation">;</span>
                new_count<span class="token punctuation">.</span>internal_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
                new_count<span class="token punctuation">.</span>external_counters<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
                count<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>new_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
                next<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
                next<span class="token punctuation">.</span>external_count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
            <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_data</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token function">T</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                counted_node_ptr new_next<span class="token punctuation">;</span>
                new_next<span class="token punctuation">.</span>node_ptr new_next<span class="token punctuation">;</span>
                new_next<span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> node<span class="token punctuation">;</span>
                new_next<span class="token punctuation">.</span>external_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token function">increase_external_count</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    T<span class="token operator">*</span> old_data<span class="token operator">=</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_data<span class="token punctuation">,</span>new_data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>next<span class="token operator">=</span>new_next<span class="token punctuation">;</span>
                        old_tail<span class="token operator">=</span>tail<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>new_next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">free_external_counter</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        new_data<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                    
                    <span class="token punctuation">}</span>
                    old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span><span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>从无锁队列弹出尾节点,该尾节点采取了引用计数</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-void">void</span> <span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">increase_external_count</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
                node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> ptr<span class="token operator">=</span>old_head<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span>tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ptr<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    ptr<span class="token operator">-&gt;</span><span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    T<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> res<span class="token operator">=</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">free_external_counter</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                ptr<span class="token operator">-&gt;</span><span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>在无锁队列中针对某节点的释放引用</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-void">void</span> <span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                node_counter old_count<span class="token operator">=</span>count<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
                node_counter new_count<span class="token punctuation">;</span>
                <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span>
                    <span class="token keyword keyword-new">new</span> counter<span class="token operator">=</span>old_count<span class="token punctuation">;</span>
                    <span class="token operator">--</span>new_counter<span class="token punctuation">.</span>internal_count<span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>count<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_count<span class="token punctuation">,</span>new_counter<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>new_counter<span class="token punctuation">.</span>internal_count<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>new_counter<span class="token punctuation">.</span>external_counters<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword keyword-delete">delete</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>在无锁队列中针对某节点获取新引用</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">increase_external_count</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>counted_node_ptr<span class="token operator">&gt;</span><span class="token operator">&amp;</span> counter<span class="token punctuation">,</span>counted_node_ptr<span class="token operator">&amp;</span> old_counter<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr new_counter<span class="token punctuation">;</span>
            <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span>
                new_counter<span class="token operator">=</span>old_counter<span class="token punctuation">;</span>
                <span class="token operator">++</span>new_counter<span class="token punctuation">.</span>external_count<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>counter<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_counter<span class="token punctuation">,</span>new_counter<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_acquire<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            old_counter<span class="token punctuation">.</span>external_count<span class="token operator">=</span>new_counter<span class="token punctuation">.</span>external_count<span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>针对无锁队列的节点释放其外部计数器</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">free_external_counter</span><span class="token punctuation">(</span>counted_node_ptr<span class="token operator">&amp;</span> old_node_ptr<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> ptr<span class="token operator">=</span>old_node_ptr<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
            <span class="token keyword keyword-int">int</span> <span class="token keyword keyword-const">const</span> count_increase<span class="token operator">=</span>old_node_ptr<span class="token punctuation">.</span>external_count<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
            node_counter new_counter<span class="token punctuation">;</span>
            <span class="token keyword keyword-do">do</span><span class="token punctuation">{</span>
                new_counter <span class="token operator">=</span> old_counter<span class="token punctuation">;</span>
                <span class="token operator">--</span>new_counter<span class="token punctuation">.</span>external_counters<span class="token punctuation">;</span>
                new_counter<span class="token punctuation">.</span>internal_count<span class="token operator">+=</span>count_increase<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token operator">-&gt;</span>count<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_counter<span class="token punctuation">,</span>new_counter<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>new_counter<span class="token punctuation">.</span>internal_count<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>new_counter<span class="token punctuation">.</span>external_counters<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-delete">delete</span> ptr<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>经过修改的pop()可以协助队列的push()操作</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">node</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>node_counter<span class="token operator">&gt;</span> count<span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span>counted_node_ptr<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            counted_node_ptr old_head<span class="token operator">=</span>head<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">increase_external_count</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
                node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> ptr<span class="token operator">=</span>old_head<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span>tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ptr<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                counted_node_ptr next<span class="token operator">=</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_head<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    T<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> res<span class="token operator">=</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">free_external_counter</span><span class="token punctuation">(</span>old_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                ptr<span class="token operator">-&gt;</span><span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>无锁队列中的push()范例,它能接受另一线程的协助</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">lock_free_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">set_new_tail</span><span class="token punctuation">(</span>counted_node_ptr<span class="token operator">&amp;</span>old_tail<span class="token punctuation">,</span>counted_node_ptr <span class="token operator">&amp;</span>new_tail<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            node<span class="token operator">*</span> <span class="token keyword keyword-const">const</span> current_tail_ptr<span class="token operator">=</span>old_tail<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>tail<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span>new_tail<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">==</span>current_tail_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">!=</span>current_tail_ptr<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">free_external_counter</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span>
            <span class="token punctuation">{</span>
                current_tail_ptr<span class="token operator">-&gt;</span><span class="token function">release_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>T new_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_data</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token function">T</span><span class="token punctuation">(</span>new_value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            counted_node_ptr new_next<span class="token punctuation">;</span>
            new_next<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">;</span>
            new_next<span class="token punctuation">.</span>external_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
            counted_node_ptr old_tail<span class="token operator">=</span>tail<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">increase_external_count</span><span class="token punctuation">(</span>tail<span class="token punctuation">,</span>old_tail<span class="token punctuation">)</span><span class="token punctuation">;</span>
                T <span class="token operator">*</span> old_data<span class="token operator">=</span><span class="token keyword keyword-nullptr">nullptr</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>data<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_data<span class="token punctuation">,</span>new_data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    counted_node_ptr old_next<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_next<span class="token punctuation">,</span>new_next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        <span class="token keyword keyword-delete">delete</span> new_next<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>
                        new_next<span class="token operator">=</span>old_next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token function">set_new_tail</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span>new_next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    new_data<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span>
                <span class="token punctuation">{</span>
                    counted_node_ptr old_next<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>old_tail<span class="token punctuation">.</span>ptr<span class="token operator">-&gt;</span>next<span class="token punctuation">.</span><span class="token function">compare_exchange_strong</span><span class="token punctuation">(</span>old_next<span class="token punctuation">,</span>new_next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        old_next<span class="token operator">=</span>new_next<span class="token punctuation">;</span>
                        new_next<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword keyword-new">new</span> node<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token function">set_new_tail</span><span class="token punctuation">(</span>old_tail<span class="token punctuation">,</span>old_next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h3 id="实现无锁数据结构的原则">实现无锁数据结构的原则 </h3>
<h4 id="原则1在原型设计中使用stdmemory_order_seq_cst次序">原则1：在原型设计中使用std::memory_order_seq_cst次序 </h4>
<p>若代码服从std::memory_order_seq_cst次序,会令全部操作形成一个确定的总序列。</p>
<h4 id="原则2使用无锁的内存回收方案">原则2：使用无锁的内存回收方案 </h4>
<ol>
<li>暂缓全部删除对象的动作,等到没有线程访问数据结构的时候,才删除待销毁的对象</li>
<li>采用风险指针,以辨识特定对象是否正在被某线程访问,就对象进行引用计数,只要外部环境正在指涉目标对象,它就不会被删除</li>
<li>就对象进行引用计数,只要外部环境仍在指涉目标对象,它就不会被删除</li>
</ol>
<h4 id="原则3-防范aba问题">原则3: 防范ABA问题 </h4>
<p>问题产生过程如下:</p>
<ol>
<li>线程甲读取原子变量x,得知其值为A</li>
<li>线程甲根据A执行某项操作,比如查找,或如果x是指针，则依据它提取出相关值(称为ov)</li>
<li>线程甲因操作系统调度而发生阻塞</li>
<li>另一线程对原子变量x执行别的操作,将其值改成B</li>
<li>又有线程改变了与A相关的数据,是的线程甲原本持有的值失效,（这种情形肯呢个为A表示某内存地址，而改动操作则是释放指针的目标内存，或变更目标数据，最后将产生严重后果</li>
<li>原子变量x再次被某线程改动，重新变回A,若x属于指针型别,其指向目标可能在步骤5被改换成一个新对象</li>
<li>线程甲继续运行,在原子变量x上执行比较交换操作,与A进行对比，因此比较操作成功（因x的值依然为A），但步骤2中的ov已经失效,而线程甲却无从分辨,这将破坏数据结构</li>
</ol>
<h4 id="原则4找出忙等循环协助其他线程">原则4：找出忙等循环,协助其他线程 </h4>
<p>阻塞型操作与使用互斥和锁一样,三者均有可能以忙等循环的方式循环<br>
假设按照调度安排,某线程先开始执行,却因另一线程的操作而暂停等待,那么只要我们修改操作的算法,就能让前者先完成全部步骤,从而避免忙等：这要求将非原子变量的数据成员改为原子变量,并采用比较-交换操作设置其值</p>
<hr>
<h2 id="设计并发代码">设计并发代码 </h2>
<h3 id="在线程间切分任务的方法">在线程间切分任务的方法 </h3>
<ol>
<li>
<p>先在线程间切分数据,再开始处理</p>
</li>
<li>
<p>以递归方式划分数据</p>
</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">Parallel_Quick_Sort_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Parallel_Quick_Sort_HPP</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.future.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread_safe_stack.hpp"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>


<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sorter</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">chunk_to_sort</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> promise<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    thread_safe_stack<span class="token operator">&lt;</span>chunk_to_sort<span class="token operator">&gt;</span> chunks<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> max_thread_count<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> end_of_data<span class="token punctuation">;</span>
    <span class="token function">sorter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">max_thread_count</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">end_of_data</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">sorter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        end_of_data <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>threads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">try_sort_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>chunk_to_sort<span class="token operator">&gt;</span> chunk <span class="token operator">=</span> chunks<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">sort_chunk</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">do_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>chunk_data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> chunk_data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> partition_val <span class="token operator">=</span> <span class="token operator">*</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator divide_point<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">partition</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> val<span class="token operator">&lt;</span>partition_val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        chunk_to_sort new_lower_chunk<span class="token punctuation">;</span>
        new_lower_chunk<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>new_lower_chunk<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>divide_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> lower_future <span class="token operator">=</span> new_lower_chunk<span class="token punctuation">.</span>promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        chunks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>new_lower_chunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>threads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>max_thread_count<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sorter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>sort_thread<span class="token punctuation">,</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">new_higher</span><span class="token punctuation">(</span><span class="token function">do_sort</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_higher<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>new_lower<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">try_sort_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">sort_chunk</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>chunk_to_sort<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> chunk<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        chunk<span class="token operator">-&gt;</span>promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token function">do_sort</span><span class="token punctuation">(</span>chunk<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">sort_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>end_of_data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">try_sort_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">parallel_quick_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
   <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span> data<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   sorter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> sorter<span class="token punctuation">;</span>
   <span class="token keyword keyword-return">return</span> sorter<span class="token punctuation">.</span><span class="token function">do_sort</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// Parallel_Quick_Sort_HPP</span></span>
</code></pre><ol start="3">
<li>依据工作类别划分任务</li>
</ol>
<h3 id="影响并发代码性能的因素">影响并发代码性能的因素 </h3>
<ol>
<li>处理器数量</li>
<li>数据竞争和缓存乒乓：<br>
例如fetch_and_add操作,并采用了std::memory_order_relaxed内存次序,如果俩个线程在两个处理器上运行相同的代码,两个处理器的缓存中将分别形成变量counter的副本,它们必须在两个处理器之间来回传递,两者所含的counter值才可以保持最新,从而正确执行自增操作,如果运行上述代码的处理器数量过多,或者数据处理过快,各处理器可能彼此等待<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
my_data data<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">processing_loop_with_mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
     std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">done_processing</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></li>
</ol>
<p>假定多个线程要访问数据data和互斥m,那么,若系统具有越多核心或处理器,高度争夺就越可能发生,即处理器可能相互等待</p>
<ol start="3">
<li>
<p>不经意共享<br>
假定多个线程要访问一个整型数组,其中各线程都具有专属的元素,且只反复读写自己的元素,由于整型变量的尺寸往往比换存款小很多,因此同一缓存快能够容纳多个数组元素,结果,尽管个线程仅访问数组中属于自己的元素,但仍会让硬件产生缓存乒乓问题,原因是一个缓存块内可能包含了两个线程所需要的元素集合,而数据以缓存块形式传递</p>
</li>
<li>
<p>数据的紧凑程度<br>
太紧凑会发生上述的不经意共享问题,而太稀疏则会导致闲散数据远多于有用数据造成缓存浪费</p>
</li>
<li>
<p>过度任务切换与线程过饱和</p>
</li>
</ol>
<h3 id="设计数据结构以提升多线程程序的性能">设计数据结构以提升多线程程序的性能 </h3>
<ol>
<li>针对复杂操作的数据划分</li>
<li>其他数据结构的访问模式<br>
如果互斥与受保护的数据位于同一缓存块中,此时其他线程再试图加锁,那么在互斥上持锁的线程就会遭受性能损失,要确定这种不经意共享是否真的构成问题,其中一种测试方法是针对不同线程并发访问的各项数据,在它们之间加入巨大的填充块</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">protected_data</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> padding<span class="token punctuation">[</span>std<span class="token double-colon punctuation">::</span>hardware_destructive_interference_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    my_data data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>或者,采用下面的代码进行测试,判定数组元素之间是否存在不经意的共享</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">protected_data</span>
<span class="token punctuation">{</span>
    data_item1 d1<span class="token punctuation">;</span>
    data_item2 d2<span class="token punctuation">;</span>
    <span class="token keyword keyword-char">char</span> padding<span class="token punctuation">[</span>std<span class="token double-colon punctuation">::</span>hardware_destructive_interference_size<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
my_data some_array<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><h3 id="设计并发代码时额外要考虑的因素">设计并发代码时额外要考虑的因素 </h3>
<ol>
<li>并行算法代码中的异常安全</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">accumulate_block</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>T<span class="token operator">&amp;</span> result<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        result<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">parallel_accumulate</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>T init<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>length<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> init<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_threads<span class="token operator">=</span><span class="token punctuation">(</span>length<span class="token operator">+</span>min_per_thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>min_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hardware_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>hardware_threads<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>hardware_threads<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>max_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> block_size<span class="token operator">=</span>length<span class="token operator">/</span>num_threads<span class="token punctuation">;</span>    
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">results</span><span class="token punctuation">(</span>num_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">threads</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_end<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_end<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">accumulate_block</span><span class="token generic class-name"><span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>block_start<span class="token punctuation">,</span>block_end<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token generic-function"><span class="token function">accumulate_block</span><span class="token generic class-name"><span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">,</span>results<span class="token punctuation">[</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>threads<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>threads<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">mem_fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>results<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>results<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>算法需要计算出一个值并将其返回,同时允许相关代码抛出异常<br>
采用std::packaged_task和std::future改写算法</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">accumulate_block</span>  
<span class="token punctuation">{</span>
    T <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span> Iterator last<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> T<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span> <span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">parallel_accumulate</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>T init<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>length<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> init<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_threads<span class="token operator">=</span><span class="token punctuation">(</span>length<span class="token operator">+</span>min_per_thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>min_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hardware_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>hardware_threads<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>hardware_threads<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>max_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> block_size<span class="token operator">=</span>length<span class="token operator">/</span>num_threads<span class="token punctuation">;</span> 
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token function">futures</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">threads</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_end<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_end<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">T</span><span class="token punctuation">(</span>Iterator<span class="token punctuation">,</span>Iterator<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>accumulate_block<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span>block_start<span class="token punctuation">,</span>block_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T last_result <span class="token operator">=</span> accumulate_block<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>threads<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>threads<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">mem_fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    T result<span class="token operator">=</span>init<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        result<span class="token operator">+=</span>futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    result<span class="token operator">+</span> <span class="token operator">=</span> last_result<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
</code></pre><p>上面的修改解决了一个潜在问题:工作线程所抛出的异常会被future捕获，转而在主线程上重新抛出,假设抛出的异常不止一个,那就只有一个异常能够向上传递</p>
<p>从第一个线程创建开始,直到全部汇合完成再有异常可能会导致线程泄露,解决方法是</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_end<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_end<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">accumulate_block</span><span class="token generic class-name"><span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>block_start<span class="token punctuation">,</span>block_end<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token generic-function"><span class="token function">accumulate_block</span><span class="token generic class-name"><span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">,</span>results<span class="token punctuation">[</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>threads<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>threads<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">mem_fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><p>更好的解决办法是设计一个类,提取出重复代码</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">join_threads</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span><span class="token operator">&amp;</span> threads<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">join_threads</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span><span class="token operator">&amp;</span> threads_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">threads</span><span class="token punctuation">(</span>threads_<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">join_threads</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>threads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><ol start="2">
<li>std::async的线程安全<br>
std::async会让线程库替我们管控线程,任何生成的线程一但运行完成,对应的future即进入就绪状态,如果不等future进入就绪状态就将其销毁,future对象的析构函数依然会等待期线程运行结束,否则,线程仍会运行，上面的等待巧妙的避免了线程持有指向局部数据的引用导致线程资源丢失的问题</li>
</ol>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">parallel_accumulate</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>T init<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_chunk_size<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">&lt;=</span>max_chunk_size<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
        Iterator mid_point<span class="token operator">=</span>first<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>mid_point<span class="token punctuation">,</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> first_half_result<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>parallel_accumulate<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>first<span class="token punctuation">,</span>mid_point<span class="token punctuation">,</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
        T second_half_result<span class="token operator">=</span><span class="token function">parallel_accumulate</span><span class="token punctuation">(</span>mid_point<span class="token punctuation">,</span>last<span class="token punctuation">,</span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> first_half_result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>second_half_result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>借并发特性改进相应能力<br>
分离GUI线程和任务线程</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>thread task_thread<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span><span class="token function">task_cancelled</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">gui_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        event_data event<span class="token operator">=</span><span class="token function">get_event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token operator">==</span>quit<span class="token punctuation">)</span> <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token function">process_event</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">task_completed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>task_cancelled<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">do_task_work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>task_cancelled<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perform_cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
    <span class="token punctuation">{</span>
        <span class="token function">post_gui_event</span><span class="token punctuation">(</span>task_complete<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">process</span><span class="token punctuation">(</span>event_data <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> event<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-switch">switch</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-case">case</span> start_task<span class="token operator">:</span>
            task_thread<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-case">case</span> cancel_task<span class="token operator">:</span>
            task_cancelled<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            task_thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-default">default</span><span class="token operator">:</span>
            <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="并发代码的设计实践">并发代码的设计实践 </h3>
<p>并行版std::for_each</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">paralllel_for_each</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>Func f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_threads<span class="token operator">=</span><span class="token punctuation">(</span>length<span class="token operator">+</span>min_per_thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>min_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hardware_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>hardware_threads<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>hardware_threads<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>max_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> block_size<span class="token operator">=</span>length<span class="token operator">/</span>num_threads<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;&gt;</span> <span class="token function">futures</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_end<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_end<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span>Iterator<span class="token punctuation">,</span>Iterator<span class="token punctuation">,</span>Func<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>block_end<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_end<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>采用std::async改写parallel_for_each</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">parallel_for_each</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>func f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>min_per_thread<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
    <span class="token punctuation">{</span>
        Iterator <span class="token keyword keyword-const">const</span> mid_point<span class="token operator">=</span>first<span class="token operator">+</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> first_half_result<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>parallel_for_each<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>Func<span class="token operator">&gt;</span><span class="token punctuation">,</span>first<span class="token punctuation">,</span>mid_point<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">parallel_for_each</span><span class="token punctuation">(</span>mid_point<span class="token punctuation">,</span>last<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        first_half_result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">parallel_for_each</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>Func f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">*</span>min_per_thread<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
    <span class="token punctuation">{</span>
        Iterator <span class="token keyword keyword-const">const</span> mid_point<span class="token operator">=</span>first<span class="token operator">+</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token operator">&gt;</span> first_half_result<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>parallel_for_each<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>Func<span class="token operator">&gt;</span><span class="token punctuation">,</span>first<span class="token punctuation">,</span>mid_point<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">parallel_for_each</span><span class="token punctuation">(</span>mid_point<span class="token punctuation">,</span>last<span class="token punctuation">,</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        first_half_result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_threads<span class="token operator">=</span><span class="token punctuation">(</span>length<span class="token operator">+</span>min_per_thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>min_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hardware_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>hardware_threads<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>hardware_threads<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>max_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> block_size<span class="token operator">=</span>length<span class="token operator">/</span>num_threads<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>Iterator<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> done<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span><span class="token function">threads</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        join_threads <span class="token function">joiner</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Iterator block_start <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
           Iterator block_end <span class="token operator">=</span> block_start<span class="token punctuation">;</span>
           std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_end<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
           threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token function">find_element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>block_start<span class="token punctuation">,</span>block_end<span class="token punctuation">,</span>match<span class="token punctuation">,</span><span class="token operator">&amp;</span>result<span class="token punctuation">,</span><span class="token operator">&amp;</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">find_element</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>match<span class="token punctuation">,</span><span class="token operator">&amp;</span>result<span class="token punctuation">,</span><span class="token operator">&amp;</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>done_result<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">MatchType</span><span class="token operator">&gt;</span>
Iterator <span class="token function">parallel_find_impl</span><span class="token punctuation">(</span>Iterator begin<span class="token punctuation">,</span> Iterator end<span class="token punctuation">,</span> MatchType match<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> done<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>min_per_thread<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>first<span class="token operator">!=</span>last <span class="token operator">&amp;&amp;</span><span class="token operator">!</span>done<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>first<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-return">return</span> first<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> last<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
            Iterator <span class="token keyword keyword-const">const</span> mid_point <span class="token operator">=</span> first<span class="token operator">+</span><span class="token punctuation">(</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>Iterator<span class="token operator">&gt;</span> async_result <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parallel_find_impl<span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>MatchType<span class="token operator">&gt;</span><span class="token punctuation">,</span>mid_point<span class="token punctuation">,</span>last<span class="token punctuation">,</span>match<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Iterator <span class="token keyword keyword-const">const</span> direct_result<span class="token operator">=</span><span class="token function">parallel_find_impl</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>mid_point<span class="token punctuation">,</span>match<span class="token punctuation">,</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> direct_result<span class="token operator">!=</span>last<span class="token operator">?</span>direct_result<span class="token operator">:</span>async_result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">MatchType</span><span class="token operator">&gt;</span>
Iterator <span class="token function">parallel_find</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span> Iterator last<span class="token punctuation">,</span> MatchType match<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> <span class="token function">done</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">parallel_find_impl</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>match<span class="token punctuation">,</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>并行化std::partial_sum<br>
以划分数据段计算前缀和</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">parallel_partial_sum</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span> Iterator last<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">process_chunk</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Iterator begin<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span><span class="token operator">*</span> previous_end_value<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span><span class="token operator">*</span>end_value<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-try">try</span>
            <span class="token punctuation">{</span>
                Iterator end <span class="token operator">=</span> last<span class="token punctuation">;</span>
                <span class="token operator">++</span>end<span class="token punctuation">;</span>
                std<span class="token double-colon punctuation">::</span><span class="token function">partial_sum</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>previous_end_value<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    value_type<span class="token operator">&amp;</span> addend <span class="token operator">=</span> previous_end_value<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">*</span>last<span class="token operator">+=</span>addend<span class="token punctuation">;</span>
                    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>end_value<span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        end_value<span class="token operator">-&gt;</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span>last<span class="token punctuation">,</span><span class="token punctuation">[</span>addend<span class="token punctuation">]</span><span class="token punctuation">(</span>value_type<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        item<span class="token operator">+=</span>addend<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>end_value<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    end_value<span class="token operator">-&gt;</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token operator">*</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                                                                                                                            
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>end_value<span class="token punctuation">)</span> end_value<span class="token operator">-&gt;</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> min_per_thread<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> max_threads<span class="token operator">=</span><span class="token punctuation">(</span>length<span class="token operator">+</span>min_per_thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>min_per_thread<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> hardware_threads<span class="token operator">=</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_threads<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span>hardware_threads<span class="token operator">!=</span><span class="token number">0</span><span class="token operator">?</span>hardware_threads<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>max_threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> chunk_size<span class="token operator">=</span>length<span class="token operator">/</span>num_threads<span class="token punctuation">;</span>
    <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">threads</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">previous_end_values</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">end_values</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    previout_end_values<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    join_threads <span class="token function">joiner</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span>num_threads<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_last<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_last<span class="token punctuation">,</span>block_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token function">process_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>block_start<span class="token punctuation">,</span>block_last<span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">&amp;</span>previous_end_values<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>end_values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_last<span class="token punctuation">;</span>
        <span class="token operator">++</span>block_start<span class="token punctuation">;</span>
        previous_end_values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>end_values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Iterator final_element <span class="token operator">=</span> block_start<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>final_element<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">process_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>final_element<span class="token punctuation">,</span><span class="token punctuation">(</span>num_threads<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">&amp;</span>previous_end_values<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码通过分段计算前缀和,再分批加上前一段的末尾和来计算<br>
别计算出{1,3,6} 、 {4,9,15} 、 {7,15,24} 。第一段的末项值<br>
为 6, 我们将它与第二段的结果逐项相加，得到 {1, 3, 6} 、 {10 , 15, 21} 、 {7, 15 , 24 } 。 第<br>
二段的末项值是 21, 它接着与第三段（也是最后的数据段）的结果依次相加 ， 产生最终<br>
结果 {l, 3, 6} 、 {10, 15, 21} 、 {28,36,45} 。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-struct">struct</span> <span class="token class-name">barrier</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token operator">&gt;</span> count<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token operator">&gt;</span> spaces<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-unsigned">unsigned</span><span class="token operator">&gt;</span> generation<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-explicit">explicit</span> <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> count<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">count</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">spaces</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">generation</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> my_generation<span class="token operator">=</span>generation<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>spaces<span class="token punctuation">)</span><span class="token comment">//当空座递减为0时，说明所有线程都已经到达线程卡,generation才更新</span>
        <span class="token punctuation">{</span>
            spaces<span class="token operator">=</span>count<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>generation<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>generation<span class="token operator">==</span>my_generation<span class="token punctuation">)</span>
                std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">done_waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//减少线程,剔除线程卡</span>
    <span class="token punctuation">{</span>
        <span class="token operator">--</span>count<span class="token punctuation">;</span>        
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>spaces<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            spaces<span class="token operator">=</span>count<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>generation<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">parallel_partial_sum</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token double-colon punctuation">::</span>value_type value_type<span class="token punctuation">;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">process_element</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token punctuation">,</span>barrier<span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            value_type<span class="token operator">&amp;</span> ith_element<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>first<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-bool">bool</span> update_source <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> step<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>stride<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span><span class="token operator">++</span>step<span class="token punctuation">,</span>stride<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                value_type <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> source <span class="token operator">=</span> <span class="token punctuation">(</span>step<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">?</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span>ith_element<span class="token punctuation">;</span>
                value_type <span class="token operator">&amp;</span> dest <span class="token operator">=</span> <span class="token punctuation">(</span>step<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">?</span> itehr_element<span class="token operator">:</span>buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                value_type <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> addend <span class="token operator">=</span> <span class="token punctuation">(</span>step<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">?</span> buffer<span class="token punctuation">[</span>i<span class="token operator">-</span>stride<span class="token punctuation">]</span><span class="token operator">:</span><span class="token operator">*</span><span class="token punctuation">(</span>first<span class="token operator">+</span>i<span class="token operator">-</span>stride<span class="token punctuation">)</span><span class="token punctuation">;</span>
                dest<span class="token operator">=</span>source<span class="token operator">+</span>addend<span class="token punctuation">;</span>
                update_source <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>step<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                b<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>update_source<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                ith_element <span class="token operator">=</span> buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            b<span class="token punctuation">.</span><span class="token function">done_waiting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>value_type<span class="token operator">&gt;</span> <span class="token function">buffer</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    barrier <span class="token function">b</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> <span class="token function">threads</span><span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    join_threads <span class="token function">joiner</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token function">process_element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">process_element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码通过逐轮计算前缀和,并通过栅栏同步线程,减少线程卡<br>
以2的次幂进行划分数据段,并行计算前缀和<br>
假设我们还是计算序列{1,2,3,4,5,6,7,8,9}的前缀和，那么第一轮操作便会得出 {l, 3, 5, 7, 9, 11, 13, 15, 17}, 其中前两个元素即为最终结果。第二轮操作会得到 {1, 3, 6, 10, 14, 18, 22, 26, 30}, 这时前 4 项元素已完成计算。第三轮如乍后我们求出 {1, 3, 6, 10, 15, 21, 28, 36, 44}, 其中前 8 项元素都是正确结果，最后一轮会产生 {l, 3, 6, 10, 15 ,21, 28, 36, 45}</p>
<hr>
<h2 id="高级线程管理">高级线程管理 </h2>
<h3 id="线程池">线程池 </h3>
<p>线程池的最简单实现是,采用数目固定的工作线程,每当有任务需要处理时,调用函数让它放在任务队列中<br>
等待,各工作线程从队列中领取指定的任务并运行,然后再回到队列领取其他任务</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">thread_pool</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic_bool done<span class="token punctuation">;</span>
    threadsafe_queue<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> work_queue<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>
    join_threads joiner<span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>task<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>work_queue<span class="token punctuation">.</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">thread_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">joiner</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> thread_count<span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>thread_count<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_pool<span class="token double-colon punctuation">::</span>worker_thread<span class="token punctuation">,</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            done<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
        
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">thread_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        done<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">FunctionType</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">submit</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        work_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">function</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword keyword-void">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>一个线程池,使用者可以等待池内任务完成</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">function_wrapper</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">impl_base</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-virtual">virtual</span> <span class="token keyword keyword-void">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-virtual">virtual</span> <span class="token operator">~</span><span class="token function">impl_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>impl_base<span class="token operator">&gt;</span> impl<span class="token punctuation">;</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">impl_type</span><span class="token operator">:</span><span class="token base-clause"><span class="token class-name">impl_base</span></span>
    <span class="token punctuation">{</span>
        F f<span class="token punctuation">;</span>
        <span class="token function">impl_type</span><span class="token punctuation">(</span>F f_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>F <span class="token operator">&amp;&amp;</span>f<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">impl</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token generic-function"><span class="token function">impl_type</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">move</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl<span class="token operator">-&gt;</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-default">default</span><span class="token punctuation">;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    function_wrapper <span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> function_wrapper <span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    function_wrapper<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> function_wrapper <span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">thread_pool</span><span class="token punctuation">{</span>
    threadsafe_queue<span class="token operator">&lt;</span>function_wrapper<span class="token operator">&gt;</span> work_queue<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic_bool done<span class="token punctuation">;</span>

    <span class="token keyword keyword-void">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            function_wrapper task<span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>work_queue<span class="token punctuation">.</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-else">else</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">FunctionType</span><span class="token operator">&gt;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span> <span class="token function">submit</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type result_type<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">result_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        work_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">thread_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        done<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>我们把函数f 包装在 std: :packaged_task&lt;result_type()&gt;中，因为句是函数或可调用对象，不接收参数，返回值是 result_type 型别的实例。根据推导 ，两者彼此相<br>
符。接着，我们从 std: :packaged_tas k&lt;&gt; 取得对应的futur忒趴然后将任务压入队列 ，<br>
再向 submit的调用者返回future）。请注意，由于 std: :packaged_tas k&lt;&gt;不可复制 ，因此<br>
一定要通过 std::move 把任务压入队列。照此修改，任务队列存储的元素是function_wrapper 对象，而不再是 std::function<void>对象。现在，线程池遂能够依从前文的新<br>
方式处理任务</void></p>
<p>采用线程池实现的parallel_accumulate()函数,运算过程及等待池内任务完成</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Iterator</span><span class="token punctuation">,</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">parallel_accumulate</span><span class="token punctuation">(</span>Iterator first<span class="token punctuation">,</span>Iterator last<span class="token punctuation">,</span>T init<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> length<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">distance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>length<span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> init<span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> block_size<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-const">const</span> num_blocks<span class="token operator">=</span> <span class="token punctuation">(</span>length<span class="token operator">+</span>block_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span>block_size<span class="token punctuation">;</span>
    thread_pool pool<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token function">futures</span><span class="token punctuation">(</span>num_blocks<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Iterator block_start<span class="token operator">=</span>first<span class="token punctuation">;</span>
<span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_blocks<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Iterator block_last<span class="token operator">=</span>block_start<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>block_last<span class="token punctuation">,</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
            <span class="token function">accumulate_block</span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>block_last<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        block_start<span class="token operator">=</span>block_last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    T last_result<span class="token operator">=</span><span class="token generic-function"><span class="token function">accumulate_block</span><span class="token generic class-name"><span class="token operator">&lt;</span>Iterator<span class="token punctuation">,</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>block_start<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>
    T result <span class="token operator">=</span> init<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num_blocks<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        result<span class="token operator">+=</span>futures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    result<span class="token operator">+=</span>last_result<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>线程数目有限,若耗尽了空闲线程,就可能令他们全都停滞不前,空等哪些尚待调度执行的任务<br>
因此,我们需要采用的解决办法与第8章相似,在等待目标数据块完成操作的过程中,主动处理相关的还未排序的数据块<br>
若采用线程池管理任务列表及其关联线程,则完全不必直接访问任务列表就能达到目的,这正是线程池的意义</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> thread_pool<span class="token double-colon punctuation">::</span><span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    function_wrapper task<span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>work_queue<span class="token punctuation">.</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-else">else</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这个实现原样提取了worker_thread()函数的主循环,并作为run_pending_task()函数而被调用<br>
基于线程池的快速排序实现</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-struct">struct</span> <span class="token class-name">sorter</span>
<span class="token punctuation">{</span>
    thread_pool pool<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">do_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> chunk_data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-return">return</span> chunk_data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将划分点提前存入result</span>
        T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> partition_val<span class="token operator">=</span><span class="token operator">*</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Typename std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator divide_point<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">partition</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>T <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> val<span class="token operator">&lt;</span>partition_val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> new_lower_chunk<span class="token punctuation">;</span>
        new_lower_chunk<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>new_lower_chunk<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>chunk_data<span class="token punctuation">,</span>chunk_data<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>divide_point<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token function">new_higher</span><span class="token punctuation">(</span><span class="token function">do_sort</span><span class="token punctuation">(</span>chunk_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_higher<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>new_lower<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            pool<span class="token punctuation">.</span><span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        result<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>new_lower<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">parallel_quick_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> input<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> input<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sorter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> s<span class="token punctuation">.</span><span class="token function">do_sort</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>线程池仅具备一个任务队列供多线程共用,在同一个线程池实例上,每当有线程调用submit()函数,就把新任务压入该队列,类似地,为了执行任务,工作线程不断从这一队列弹出任务</p>
<p>为了解决缓存乒乓问题,为每个线程配备独立的任务队列,各线程只在自己的队列上发布新任务,仅当线程自身的队列没有任务时,才会从全局队列领取任务、</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">thread_pool</span>
<span class="token punctuation">{</span>
    threadsafe_queue<span class="token operator">&lt;</span>function_wrapper<span class="token operator">&gt;</span> pool_work_queue<span class="token punctuation">;</span>
    <span class="token keyword keyword-typedef">typedef</span> std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>function_wrapper<span class="token operator">&gt;</span> local_queue_type<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-thread_local">thread_local</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>local_queue_type<span class="token operator">&gt;</span> local_work_queue<span class="token punctuation">;</span>
    
    <span class="token keyword keyword-void">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        local_work_queue<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> local_queue_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">FunctionType</span><span class="token operator">&gt;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span><span class="token function">submit</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type result_type<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">result_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>local_work_queue<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            local_work_queue<span class="token operator">-&gt;</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span>
        <span class="token punctuation">{</span>
            pool_work_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        function_wrapper task<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>local_work_queue <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>local_work_queue<span class="token operator">-&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            task <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>local_work_queue<span class="token operator">-&gt;</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            local_work_queue<span class="token operator">-&gt;</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>pool_work_queue<span class="token punctuation">.</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>当线程自身的队列没有任务时,才会从全局队列领取任务,其中采用了thread_local变量,从而令每个线程都具有自己的任务队列,线程池本身则再维护一全局队列</p>
<h4 id="任务窃取">任务窃取 </h4>
<p>有且只有 thread_local 关键字修饰的变量具有线程（thread）周期，这些变量在线程开始的时候被生成，在线程结束的时候被销毁，并且每一个线程都拥有一个独立的变量实例。<br>
thread_local 一般用于需要保证线程安全的函数中。</p>
<p>需要注意的一点是，如果类的成员函数内定义了 thread_local 变量，则对于同一个线程内的该类的多个对象都会共享一个变量实例，并且只会在第一次执行这个成员函数时初始化这个变量实例，这一点是跟类的静态成员变量类似的。</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">STEALING_THREAD_POOL_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STEALING_THREAD_POOL_HPP</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.shared_mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.thread.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.condition_variable.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.mutex.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mingw.future.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread_safe_stack.hpp"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"join_threads.hpp"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"threadsafe_queue.hpp"</span></span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">function_wrapper</span><span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">impl_base</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-virtual">virtual</span> <span class="token keyword keyword-void">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-virtual">virtual</span> <span class="token operator">~</span><span class="token function">impl_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>impl_base<span class="token operator">&gt;</span> impl<span class="token punctuation">;</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">impl_type</span><span class="token operator">:</span><span class="token base-clause"><span class="token class-name">impl_base</span></span>
    <span class="token punctuation">{</span>
        F f<span class="token punctuation">;</span>
        <span class="token function">impl_type</span><span class="token punctuation">(</span>F f_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>F <span class="token operator">&amp;&amp;</span>f<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">impl</span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> <span class="token generic-function"><span class="token function">impl_type</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">move</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl<span class="token operator">-&gt;</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-default">default</span><span class="token punctuation">;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    function_wrapper <span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        impl <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">*</span><span class="token keyword keyword-this">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> function_wrapper <span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    <span class="token function">function_wrapper</span><span class="token punctuation">(</span>function_wrapper <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
    function_wrapper<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> function_wrapper <span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">work_stealing_queue</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-private">private</span><span class="token operator">:</span>
        <span class="token keyword keyword-typedef">typedef</span> function_wrapper data_type<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>data_type<span class="token operator">&gt;</span> the_queue<span class="token punctuation">;</span>
        <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex the_mutex<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token function">work_stealing_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token function">work_stealing_queue</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> work_stealing_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        work_stealing_queue<span class="token operator">&amp;</span> <span class="token keyword keyword-operator">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> work_stealing_queue<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword keyword-delete">delete</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">push</span><span class="token punctuation">(</span>data_type data<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>the_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            the_queue<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>the_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> the_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_pop</span><span class="token punctuation">(</span>data_type<span class="token operator">&amp;</span> res<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>the_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>the_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            res <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>the_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            the_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">try_steal</span><span class="token punctuation">(</span>data_type<span class="token operator">&amp;</span> res<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>the_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>the_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
            res <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>the_queue<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            the_queue<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-class">class</span> <span class="token class-name">thread_pool</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-typedef">typedef</span> function_wrapper task_type<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>atomic_bool done<span class="token punctuation">;</span>
    threadsafe_queue<span class="token operator">&lt;</span>task_type<span class="token operator">&gt;</span> pool_work_queue<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>work_stealing_queue<span class="token operator">&gt;&gt;</span> queues<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>
    join_threads joiner<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-thread_local">thread_local</span> work_stealing_queue<span class="token operator">*</span> local_work_queue<span class="token punctuation">;</span>
    <span class="token keyword keyword-static">static</span> <span class="token keyword keyword-thread_local">thread_local</span> <span class="token keyword keyword-unsigned">unsigned</span> my_index<span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">worker_thread</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> my_index_<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        my_index <span class="token operator">=</span> my_index_<span class="token punctuation">;</span>
        local_work_queue<span class="token operator">=</span> queues<span class="token punctuation">[</span>my_index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>   
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">pop_task_from_local_queue</span><span class="token punctuation">(</span>task_type<span class="token operator">&amp;</span> task<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword keyword-return">return</span> local_work_queue<span class="token operator">&amp;&amp;</span> local_work_queue<span class="token operator">-&gt;</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">pop_task_from_pool_queue</span><span class="token punctuation">(</span>task_type<span class="token operator">&amp;</span> task<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> pool_work_queue<span class="token punctuation">.</span><span class="token function">try_pop</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">pop_task_from_other_queue</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> index<span class="token punctuation">,</span> task_type<span class="token operator">&amp;</span> task<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>queues<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>my_index<span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>queues<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>queues<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">try_steal</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-return">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">thread_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">joiner</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-const">const</span> thread_count<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>thread_count<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                queues<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>work_stealing_queue<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword keyword-new">new</span> work_stealing_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> thread_count<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_pool<span class="token double-colon punctuation">::</span>worker_thread<span class="token punctuation">,</span> <span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            done<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-throw">throw</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">thread_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> done<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">FunctionType</span><span class="token operator">&gt;</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type_result_type<span class="token operator">&gt;</span> <span class="token function">submit</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword keyword-typedef">typedef</span> <span class="token keyword keyword-typename">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type result_type<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">result_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>result_type<span class="token operator">&gt;</span> <span class="token function">res</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>local_work_queue<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            local_work_queue<span class="token operator">-&gt;</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
            pool_work_queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">run_pending_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        task_type task<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">pop_task_from_local_queue</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token operator">||</span> <span class="token function">pop_task_from_pool_queue</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">pop_task_from_other_queue</span><span class="token punctuation">(</span>my_index<span class="token punctuation">,</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span><span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// STEALING_THREAD_POOL_HPP</span></span>
</code></pre><p>若线程池内某线程无事可做,就会范文众线程的专属队列,试图为该线程窃取任务,这样,run_pending_task()就会尝试从线程自己的队列领取任务,也会尝试从线程池的全局队列领取任务,还会尝试从其他线程的队列窃取任务</p>
<hr>
<h3 id="中断线程">中断线程 </h3>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">interrupt_flag</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-bool">bool</span> <span class="token function">is_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-thread_local">thread_local</span> interrupt_flag this_thread_interrupt_flag<span class="token punctuation">;</span>
<span class="token keyword keyword-class">class</span> <span class="token class-name">interruptible_thread</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread internal_thread<span class="token punctuation">;</span>
    interrupt_flag<span class="token operator">*</span> flag<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
        <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">FunctionType</span><span class="token operator">&gt;</span>
        <span class="token function">interruptible_thread</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>interrupt_flag<span class="token operator">*</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
            internal_thread <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">]</span><span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_thread_interrupt_flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            flag <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//中断异常传递版本的初始化</span>
        <span class="token function">interruptible_thread</span><span class="token punctuation">(</span>FunctionType f<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span>interrupt_flag<span class="token operator">*</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
            internal_thread <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">]</span><span class="token punctuation">{</span>
                p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_thread_interrupt_flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
                <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>thread_interrupted <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">handle_interruption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            flag <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
         
        <span class="token keyword keyword-void">void</span> <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                flag<span class="token operator">-&gt;</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">is_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token keyword keyword-throw">throw</span> <span class="token function">thread_interrputed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-void">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">process_next_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>上面的代码如果使用wait就无法进入interruption_point()函数,因为wait会一直阻塞,直到线程结束,而interruption_point()函数需要在线程阻塞时检测中断标志,如果中断标志被设置,则抛出异常<br>
针对条件变量std::condition_variable的interruptble_wait()函数,但存在瑕疵</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-void">void</span> <span class="token function">interruptible_wait</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">set_condition_variable</span><span class="token punctuation">(</span>cv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">clear_condition_variable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>函数先检测中断是否发生,再把条件变量与当前线程的中断标志关联起来,接着在条件变量上等待,继而解除关联,最后再次检测中断.<br>
在目标线程等待条件变量期间,若需要它中断,引发中断的线程就向条件变量广播,唤醒正在其上等待的全部线程</p>
<p>上面的代码如果在wait处抛出异常,函数会直接退出而中断标志和条件变量之间的关联没有被解除——可以通过中断标志的析构函数解除关联</p>
<p>另一个问题为条件竞争,如果在wait之前就被中断那么条件变量是否关联中断标志就无所谓了,但是如果在wait之后被中断如果不是进入interruption_point()函数,那么条件变量关联的中断标志就不会被解除,导致线程无法正常退出,因此需要在wait之后解除关联<br>
我们需要保证之间目标线程不会被唤醒,利用锁lk同时保护上述两个动作,但同时可能发生锁是否成功锁住和死锁的问题<br>
另一方法是调用wait_for替代wait,但超时时间难以设计,会出现反复唤醒的问题</p>
<p>针对条件变量std::condition_variable的interruptible_wait()函数,它支持超时就停止</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">interrupt_flag</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> flag<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">*</span> thread_cond<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">interrupt_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">thread_cond</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        flag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>set_clear_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>thread_cond<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            thread_cond<span class="token operator">-&gt;</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-bool">bool</span> <span class="token function">is_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-return">return</span> flag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">set_condition_variable</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>set_clear_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread_cond<span class="token operator">=</span><span class="token operator">&amp;</span>cv<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">clear_condition_variable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>set_clear_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread_cond<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">clear_cv_on_destruct</span>
    <span class="token punctuation">{</span>
        <span class="token operator">~</span><span class="token function">clear_cv_on_destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">clear_condition_variable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-void">void</span> <span class="token function">interruptible_wait</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">set_condition_variable</span><span class="token punctuation">(</span>cv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    interrupt_flag<span class="token double-colon punctuation">::</span>clear_cv_on_destruct guard<span class="token punctuation">;</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cv<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>如果我们需要等待某个断言成立,那么就可以把1ms的时限完全融合到断言循环之中</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Predicate</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">interruptible_wait_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lk<span class="token punctuation">,</span>Predicate pred<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">set_condition_variable</span><span class="token punctuation">(</span>cv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    interrupt_flag<span class="token double-colon punctuation">::</span>clear_cv_on_destruct guard<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">is_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span><span class="token function">pred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cv<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><h5 id="中断条件变量stdcondition_variable_any上的等待">中断条件变量std::condition_variable_any上的等待 </h5>
<p>std::condition_variable_any与std::condition_variable的区别在于前者可以配合任意型别的锁,而后者仅限于std::unique<br>
_lock<a href="std::mutex">std::mutex</a></p>
<p>std::condition_variable_any适配任意的锁，所以效果更好,interrupt_flag标志中内涵的互斥set_clear_mutex也可以传给wait</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span>  <span class="token class-name">interrupt_flag</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword keyword-bool">bool</span><span class="token operator">&gt;</span> flag<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">*</span> thread_cond<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>condition_variable_any<span class="token operator">*</span> thread_cond_any<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>mutex set_clear_mutex<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">interrupt_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">thread_cond</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">thread_cond_any</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        flag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token function">lk</span><span class="token punctuation">(</span>set_clear_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>thread_cond<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            thread_cond<span class="token operator">-&gt;</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-else">else</span> <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>thread_cond_any<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            thread_cond_any<span class="token operator">-&gt;</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Lockable</span><span class="token operator">&gt;</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable_any<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span>Lockable<span class="token operator">&amp;</span> lk<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-struct">struct</span> <span class="token class-name">custom_lock</span>
        <span class="token punctuation">{</span>
            interrupt_flag<span class="token operator">*</span> self<span class="token punctuation">;</span>
            Lockable<span class="token operator">&amp;</span> lk<span class="token punctuation">;</span>
            <span class="token function">custom_lock</span><span class="token punctuation">(</span>interrupt_flag<span class="token operator">*</span> self_<span class="token punctuation">,</span>
            std<span class="token double-colon punctuation">::</span>condition_variable_any<span class="token operator">&amp;</span> cond<span class="token punctuation">,</span>Lockable<span class="token operator">&amp;</span> lk_<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">self</span><span class="token punctuation">(</span>self_<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">lk</span><span class="token punctuation">(</span>lk_<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                self<span class="token operator">-&gt;</span>set_clear_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                self<span class="token operator">-&gt;</span>thread_cond_any<span class="token operator">=</span><span class="token operator">&amp;</span>cond<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-void">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                lk<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                self<span class="token operator">-&gt;</span>set_clear_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-void">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>self<span class="token operator">-&gt;</span>set_clear_mutex<span class="token punctuation">,</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        custom_lock <span class="token function">cl</span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span>cv<span class="token punctuation">,</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">Lockable</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">interruptible_wait</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>condition_variable_any<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span>Lockable<span class="token operator">&amp;</span> lk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    this_thread_interrupt_flag<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>cv<span class="token punctuation">,</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>余下代码与std::condition_variable时的interrupt_flag 相同</p>
<h5 id="中断其他阻塞型等待">中断其他阻塞型等待 </h5>
<p>上面的代码补全了条件变量上的等待,但和存在包括互斥锁,future等等的等待<br>
一般的方法是借助std::condition_variable所用到的限时功能</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-template">template</span><span class="token operator">&lt;</span><span class="token keyword keyword-typename">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">interruptible_wait</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token operator">!</span>this_thread_flag<span class="token punctuation">.</span><span class="token function">is_set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span>
        <span class="token keyword keyword-break">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>该函数一直等待,直到中断标志被设置为成立才停止,或等到future准备就绪才停止,但函数内部以1ms为时限,在future上反复进行阻塞型等待<br>
wait_for()往往会至少等待一个完整的计时单元,因此,如果所用时钟的计时单元是15ms,我们就得等待15ms才会检测到中断,这会导致效率低下</p>
<h5 id="处理中断">处理中断 </h5>
<p>从上述代码中interruption_point()函数的作用是检测中断标志,如果中断标志被设置,则抛出异常,但该函数的实现依赖于具体的平台,因此,我们需要自己实现该函数<br>
可以用try/catch捕获</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>thread_interrupted <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">handle_interruption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理中断</span>
<span class="token punctuation">}</span>
</code></pre><p>我们通常希望让中断直接终结线程,故可让中断异常向上传播,但是<br>
std::thread在构造时设定了线程函数,一旦异常传播到函数外,std::terminate()就会被调用,从而终止整个程序</p>
<p>由于interrupt_thread是thread的包装类,所以初始化时同样需要传入线程函数并加上catch块,为了防止忘记这么做,可以在类的初始化代码中防止catch块,通过上述操作中断只会终止一个线程</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">interruptible_thread</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread internal_thread<span class="token punctuation">;</span>
    <span class="token function">interruptibale_thread</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        internal_thread <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span><span class="token operator">&amp;</span>p<span class="token punctuation">]</span><span class="token punctuation">{</span>
            p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_thread_interrupt_flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-try">try</span><span class="token punctuation">{</span>
                <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>thread_interrupted <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">handle_interruption</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h5 id="在应用程序退出时中断后台任务">在应用程序退出时中断后台任务 </h5>
<p>为了使文件索引及时更新总是维持最新状态,ing哟个程序需要不听运行,而当应用程序关闭时,我们需要依次结束后台程序，其中一种做法就是中断<br>
在后台监控文件系统</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span>mutex config_mutex<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>interruptible_thread<span class="token operator">&gt;</span> background_threads<span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">background_task</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> disk_id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">interruption_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fs_change fsc<span class="token operator">=</span><span class="token function">get_fs_change</span><span class="token punctuation">(</span>disk_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>fsc<span class="token punctuation">.</span><span class="token function">has_changes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">update_index</span><span class="token punctuation">(</span>fsc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">start_background_processing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    background_threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">interruptible_thread</span><span class="token punctuation">(</span>background_thread<span class="token punctuation">,</span>disk_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    background_threads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">interruptible_thread</span><span class="token punctuation">(</span>background_thread<span class="token punctuation">,</span>disk_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-int">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">start_background_processing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">process_gui_until_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>config_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>background_threads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        background_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>background_threads<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        background_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>因为一个线程不会因为中断立即结束,所以选择先中断所有线程,再等待所有线程结束</p>
<hr>
<h2 id="并行算法函数">并行算法函数 </h2>
<p>c++17引入了并行算法函数,它们是新引入的多个函数重载<br>
std::execution::par向标准库示意,允许调用采用多线程,按并行算法的形式执行<br>
其制定了三种策略:</p>
<ul>
<li>std::execution::sequenced_policy: 串行执行</li>
<li>std::execution::parallel_policy: 并行执行</li>
<li>std::execution::parallel_unsequenced_policy: 并行执行,但不保证顺序<br>
它们是三个类,由头文件execution定义,分别对应三个策略,该头文件还定义了三个对应的策略对象,作为参数向算法传递<br>
std::execution::seq<br>
std::execution::par<br>
std::execution::par_unseq</li>
</ul>
<h4 id="因指定执行策略而普遍产生的作用">因指定执行策略而普遍产生的作用 </h4>
<ol>
<li>
<p>异常行为:如果按某种执行策略调用算法,而期间有异常抛出,则后果取决于所选用的执行策略<br>
std::for_each(std::execution::par,v.begin(),v.end(),[](auto x){throw my_exception();});<br>
普通版本异常std::bad_alloc会抛出向外传播,而重载版本则会令整个程序终止</p>
</li>
<li>
<p>算法中间步骤的执行起点和时机<br>
执行策略指定了算法函数的中间步骤的执行主体</p>
</li>
</ol>
<h4 id="stdexecutionsequenced_policy">std::execution::sequenced_policy </h4>
<p>顺序策略与并行无关,它令算法函数在发起调用的线程上执行 全部操作,所有操作都由同一个线程执行,还必须服从一定的次序</p>
<h4 id="stdexecutionparallel_policy">std::execution::parallel_policy </h4>
<p>函数的内部操作可以在发起调用的线程上执行,也可以由程序库另外创建线程执行,给定一项操作,它会固定在一个线程上完整执行到底<br>
std::for_each(std::execution::parallel,v.begin(),v.end(),[](int&amp; x){x+=count;});</p>
<p>而std::for_each(std::execution::par,v.begin(),v.end(),[](int&amp; x){x+=++count;});则会因为发生数据竞争而存在问题</p>
<p>一个具有内部同步功能的类,以及作用在其上的并行算法函数操作</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token keyword keyword-class">class</span> <span class="token class-name">X</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-mutable">mutable</span> std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword keyword-public">public</span><span class="token operator">:</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> data<span class="token punctuation">;</span>
    
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-void">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword keyword-void">void</span> <span class="token function">increment_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>X<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>execution<span class="token double-colon punctuation">::</span>par<span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
        x<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码可以采用std::execution::par_unseq，因为每个元素都具备一个互斥</p>
<h4 id="访问计数">访问计数 </h4>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>

<span class="token keyword keyword-struct">struct</span> <span class="token class-name">log_info</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>string page<span class="token punctuation">;</span>
    time_t visit_time<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string browser<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-extern">extern</span> log_info <span class="token function">parse_log_line</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-using">using</span> visit_map_type <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token keyword keyword-long">long</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

visit_map_type <span class="token function">count_visits_per_page</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token keyword keyword-const">const</span><span class="token operator">&amp;</span>log_lines<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword keyword-struct">struct</span> <span class="token class-name">combine_visits</span><span class="token punctuation">{</span>
        visit_map_type <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>visit_map_type lhs<span class="token punctuation">,</span>visit_map_type rhs<span class="token punctuation">)</span><span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>rhs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-auto">auto</span><span class="token operator">&amp;</span> entry<span class="token operator">:</span>rhs<span class="token punctuation">)</span><span class="token punctuation">{</span>
                lhs<span class="token punctuation">[</span>entry<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token operator">+=</span>entry<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-return">return</span> lhs<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    visit_map_type <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>log_info log<span class="token punctuation">,</span>visit_map_type visits<span class="token punctuation">)</span><span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
        <span class="token operator">++</span>map<span class="token punctuation">[</span>log<span class="token punctuation">.</span>page<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    visit_map_type <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>visit_map_type map<span class="token punctuation">,</span>log_info log<span class="token punctuation">)</span><span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
        <span class="token operator">++</span>map<span class="token punctuation">[</span>log<span class="token punctuation">.</span>page<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    visit_map_type <span class="token keyword keyword-operator">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>log_info log1<span class="token punctuation">,</span>log_info log2<span class="token punctuation">)</span> <span class="token keyword keyword-const">const</span><span class="token punctuation">{</span>
        visit_map_type map<span class="token punctuation">;</span>
        <span class="token operator">++</span>map<span class="token punctuation">[</span>log1<span class="token punctuation">.</span>page<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>map<span class="token punctuation">[</span>log2<span class="token punctuation">.</span>page<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-return">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">transform_reduce</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>execution<span class="token double-colon punctuation">::</span>par_unseq<span class="token punctuation">,</span>log_lines<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>log_lines<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">visit_map_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">combine_visits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>parse_log_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><p>std::for_each 仅遍历元素<br>
std::transform 遍历元素并将返回值放入容器</p>
<pre data-role="codeBlock" data-info="c++" class="language-cpp c++"><code>std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">transform</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword keyword-return">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><hr>
<h2 id="多线程应用的测试和除错">多线程应用的测试和除错 </h2>
<p>与并发相关联的错误分为两大类:</p>
<ol>
<li>多余的阻塞</li>
<li>条件竞争</li>
</ol>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>